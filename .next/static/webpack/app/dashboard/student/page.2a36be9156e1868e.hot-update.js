"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/dashboard/student/page",{

/***/ "(app-pages-browser)/./src/lib/temp-storage.ts":
/*!*********************************!*\
  !*** ./src/lib/temp-storage.ts ***!
  \*********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addConversationTurn: () => (/* binding */ addConversationTurn),\n/* harmony export */   addPendingTask: () => (/* binding */ addPendingTask),\n/* harmony export */   addUser: () => (/* binding */ addUser),\n/* harmony export */   addWeeklyReport: () => (/* binding */ addWeeklyReport),\n/* harmony export */   canSubmitThisWeek: () => (/* binding */ canSubmitThisWeek),\n/* harmony export */   cleanupOldConversations: () => (/* binding */ cleanupOldConversations),\n/* harmony export */   createConversationSession: () => (/* binding */ createConversationSession),\n/* harmony export */   deleteUser: () => (/* binding */ deleteUser),\n/* harmony export */   findEventById: () => (/* binding */ findEventById),\n/* harmony export */   findUserByEmail: () => (/* binding */ findUserByEmail),\n/* harmony export */   findUserById: () => (/* binding */ findUserById),\n/* harmony export */   findUserByStudentId: () => (/* binding */ findUserByStudentId),\n/* harmony export */   findUsersByProgram: () => (/* binding */ findUsersByProgram),\n/* harmony export */   findUsersByRole: () => (/* binding */ findUsersByRole),\n/* harmony export */   findUsersByStatus: () => (/* binding */ findUsersByStatus),\n/* harmony export */   findWeeklyReportByUserAndWeek: () => (/* binding */ findWeeklyReportByUserAndWeek),\n/* harmony export */   findWeeklyReportsByUser: () => (/* binding */ findWeeklyReportsByUser),\n/* harmony export */   generateStudentId: () => (/* binding */ generateStudentId),\n/* harmony export */   getAllCalendarEvents: () => (/* binding */ getAllCalendarEvents),\n/* harmony export */   getAllUsers: () => (/* binding */ getAllUsers),\n/* harmony export */   getAllWeeklyReports: () => (/* binding */ getAllWeeklyReports),\n/* harmony export */   getConversationHistory: () => (/* binding */ getConversationHistory),\n/* harmony export */   getConversationSession: () => (/* binding */ getConversationSession),\n/* harmony export */   getCurrentWeekEnd: () => (/* binding */ getCurrentWeekEnd),\n/* harmony export */   getCurrentWeekStart: () => (/* binding */ getCurrentWeekStart),\n/* harmony export */   getEvents: () => (/* binding */ getEvents),\n/* harmony export */   getEventsForDateRange: () => (/* binding */ getEventsForDateRange),\n/* harmony export */   getMonthWeeks: () => (/* binding */ getMonthWeeks),\n/* harmony export */   getPendingTasks: () => (/* binding */ getPendingTasks),\n/* harmony export */   getUpcomingEvents: () => (/* binding */ getUpcomingEvents),\n/* harmony export */   getUserActiveSessions: () => (/* binding */ getUserActiveSessions),\n/* harmony export */   getWeekDates: () => (/* binding */ getWeekDates),\n/* harmony export */   getWeeklyReportsByDateRange: () => (/* binding */ getWeeklyReportsByDateRange),\n/* harmony export */   markTaskCompleted: () => (/* binding */ markTaskCompleted),\n/* harmony export */   tempConversations: () => (/* binding */ tempConversations),\n/* harmony export */   tempUsers: () => (/* binding */ tempUsers),\n/* harmony export */   tempWeeklyReports: () => (/* binding */ tempWeeklyReports),\n/* harmony export */   updateConversationSession: () => (/* binding */ updateConversationSession),\n/* harmony export */   updateUser: () => (/* binding */ updateUser),\n/* harmony export */   validateStudentId: () => (/* binding */ validateStudentId)\n/* harmony export */ });\n/* harmony import */ var bcryptjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! bcryptjs */ \"(app-pages-browser)/./node_modules/bcryptjs/index.js\");\n// Temporary user storage - replace with database later\n// Singleton pattern to persist data across requests\nconst globalForStorage = globalThis;\nvar _globalForStorage_tempUsers;\nconst tempUsers = (_globalForStorage_tempUsers = globalForStorage.tempUsers) !== null && _globalForStorage_tempUsers !== void 0 ? _globalForStorage_tempUsers : [];\nvar _globalForStorage_tempWeeklyReports;\nconst tempWeeklyReports = (_globalForStorage_tempWeeklyReports = globalForStorage.tempWeeklyReports) !== null && _globalForStorage_tempWeeklyReports !== void 0 ? _globalForStorage_tempWeeklyReports : [];\n// Assign to globalThis to persist across requests\nglobalForStorage.tempUsers = tempUsers;\nglobalForStorage.tempWeeklyReports = tempWeeklyReports;\nfunction addUser(user) {\n    tempUsers.push(user);\n}\nfunction findUserByEmail(email) {\n    return tempUsers.find((user)=>user.email === email);\n}\nfunction findUserByStudentId(studentId) {\n    return tempUsers.find((user)=>user.studentId === studentId);\n}\nfunction findUserById(id) {\n    return tempUsers.find((user)=>user.id === id);\n}\nfunction getAllUsers() {\n    return tempUsers;\n}\nfunction findUsersByRole(role) {\n    return tempUsers.filter((user)=>user.role === role);\n}\nfunction findUsersByProgram(program) {\n    return tempUsers.filter((user)=>user.program === program);\n}\nfunction findUsersByStatus(status) {\n    return tempUsers.filter((user)=>user.status === status);\n}\nfunction updateUser(id, updates) {\n    const userIndex = tempUsers.findIndex((user)=>user.id === id);\n    if (userIndex !== -1) {\n        tempUsers[userIndex] = {\n            ...tempUsers[userIndex],\n            ...updates,\n            updatedAt: new Date()\n        };\n        return tempUsers[userIndex];\n    }\n    return null;\n}\nfunction deleteUser(id) {\n    const userIndex = tempUsers.findIndex((user)=>user.id === id);\n    if (userIndex !== -1) {\n        return tempUsers.splice(userIndex, 1)[0];\n    }\n    return null;\n}\nfunction validateStudentId(studentId) {\n    // Formato sugerido: EST-YYYY-XXX (ej: EST-2024-001)\n    const studentIdRegex = /^EST-\\d{4}-\\d{3}$/;\n    return studentIdRegex.test(studentId);\n}\nfunction generateStudentId() {\n    const currentYear = new Date().getFullYear();\n    const existingIds = tempUsers.filter((user)=>user.studentId && user.studentId.startsWith(\"EST-\".concat(currentYear))).map((user)=>user.studentId).sort();\n    let nextNumber = 1;\n    if (existingIds.length > 0) {\n        const lastId = existingIds[existingIds.length - 1];\n        const lastNumber = parseInt(lastId.split('-')[2]);\n        nextNumber = lastNumber + 1;\n    }\n    return \"EST-\".concat(currentYear, \"-\").concat(nextNumber.toString().padStart(3, '0'));\n}\n// Weekly Reports Functions\nfunction addWeeklyReport(report) {\n    tempWeeklyReports.push(report);\n}\nfunction findWeeklyReportsByUser(userId) {\n    return tempWeeklyReports.filter((report)=>report.userId === userId);\n}\nfunction findWeeklyReportByUserAndWeek(userId, weekStart) {\n    return tempWeeklyReports.find((report)=>report.userId === userId && report.weekStart.getTime() === weekStart.getTime());\n}\nfunction getAllWeeklyReports() {\n    return tempWeeklyReports;\n}\nfunction getWeeklyReportsByDateRange(startDate, endDate) {\n    return tempWeeklyReports.filter((report)=>report.weekStart >= startDate && report.weekEnd <= endDate);\n}\n// Date utility functions\nfunction getCurrentWeekStart() {\n    const now = new Date();\n    const monday = new Date(now);\n    const day = now.getDay();\n    const diff = now.getDate() - day + (day === 0 ? -6 : 1 // Adjust for Sunday\n    );\n    monday.setDate(diff);\n    monday.setHours(0, 0, 0, 0);\n    return monday;\n}\nfunction getCurrentWeekEnd() {\n    const weekStart = getCurrentWeekStart();\n    const weekEnd = new Date(weekStart);\n    weekEnd.setDate(weekStart.getDate() + 6);\n    weekEnd.setHours(23, 59, 59, 999);\n    return weekEnd;\n}\nfunction canSubmitThisWeek(userId) {\n    const weekStart = getCurrentWeekStart();\n    const weekEnd = getCurrentWeekEnd();\n    const currentDate = new Date();\n    const existingReport = findWeeklyReportByUserAndWeek(userId, weekStart);\n    // Can submit if:\n    // 1. We are currently in this week (currentDate is between weekStart and weekEnd)\n    // 2. No report exists for this week\n    const isCurrentWeek = currentDate >= weekStart && currentDate <= weekEnd;\n    console.log(\"\\uD83D\\uDD0D Debug canSubmitThisWeek for user \".concat(userId, \":\"));\n    console.log(\"  Current date: \".concat(currentDate.toISOString()));\n    console.log(\"  Week start: \".concat(weekStart.toISOString()));\n    console.log(\"  Week end: \".concat(weekEnd.toISOString()));\n    console.log(\"  Is current week: \".concat(isCurrentWeek));\n    console.log(\"  Existing report: \".concat(existingReport ? 'YES' : 'NO'));\n    console.log(\"  Can submit: \".concat(isCurrentWeek && !existingReport));\n    return isCurrentWeek && !existingReport;\n}\nfunction getWeekDates(date) {\n    const start = new Date(date);\n    const day = start.getDay();\n    const diff = start.getDate() - day + (day === 0 ? -6 : 1);\n    start.setDate(diff);\n    start.setHours(0, 0, 0, 0);\n    const end = new Date(start);\n    end.setDate(start.getDate() + 6);\n    end.setHours(23, 59, 59, 999);\n    return {\n        start,\n        end\n    };\n}\nfunction getMonthWeeks(year, month) {\n    const weeks = [];\n    const firstDay = new Date(year, month, 1);\n    const lastDay = new Date(year, month + 1, 0);\n    let current = new Date(firstDay);\n    // Adjust to start from Monday of first week\n    const dayOfWeek = current.getDay();\n    const daysToSubtract = dayOfWeek === 0 ? 6 : dayOfWeek - 1;\n    current.setDate(current.getDate() - daysToSubtract);\n    while(current <= lastDay){\n        const weekStart = new Date(current);\n        const weekEnd = new Date(current);\n        weekEnd.setDate(weekStart.getDate() + 6);\n        weeks.push({\n            start: weekStart,\n            end: weekEnd\n        });\n        current.setDate(current.getDate() + 7);\n    }\n    return weeks;\n}\n// ===== CALENDAR FUNCTIONS =====\n// These functions integrate with the calendar system for Sara AI\nfunction getEvents(userId) {\n    // Import calendar data functions\n    try {\n        const { getUserCalendarData } = __webpack_require__(/*! ./calendar-data */ \"(app-pages-browser)/./src/lib/calendar-data.ts\");\n        const userData = getUserCalendarData(userId);\n        return (userData === null || userData === void 0 ? void 0 : userData.events) || [];\n    } catch (error) {\n        console.error('Error getting calendar events:', error);\n        return [];\n    }\n}\nfunction getAllCalendarEvents(userId) {\n    // Alias for getEvents for compatibility\n    return getEvents(userId);\n}\nfunction getUpcomingEvents(userId) {\n    let days = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 30;\n    try {\n        const allEvents = getEvents(userId);\n        const now = new Date();\n        const futureDate = new Date();\n        futureDate.setDate(futureDate.getDate() + days);\n        return allEvents.filter((event)=>{\n            const eventDate = new Date(event.date);\n            return eventDate >= now && eventDate <= futureDate;\n        }).sort((a, b)=>new Date(a.date).getTime() - new Date(b.date).getTime());\n    } catch (error) {\n        console.error('Error getting upcoming events:', error);\n        return [];\n    }\n}\nfunction getEventsForDateRange(userId, startDate, endDate) {\n    try {\n        const allEvents = getEvents(userId);\n        return allEvents.filter((event)=>{\n            const eventDate = new Date(event.date);\n            return eventDate >= startDate && eventDate <= endDate;\n        });\n    } catch (error) {\n        console.error('Error getting events for date range:', error);\n        return [];\n    }\n}\nfunction findEventById(userId, eventId) {\n    try {\n        const allEvents = getEvents(userId);\n        return allEvents.find((event)=>event.id === eventId) || null;\n    } catch (error) {\n        console.error('Error finding event by ID:', error);\n        return null;\n    }\n}\n// Global storage for conversations\nconst globalForConversations = globalThis;\nvar _globalForConversations_tempConversations;\nconst tempConversations = (_globalForConversations_tempConversations = globalForConversations.tempConversations) !== null && _globalForConversations_tempConversations !== void 0 ? _globalForConversations_tempConversations : [];\nglobalForConversations.tempConversations = tempConversations;\nfunction getConversationSession(userId, sessionId) {\n    return tempConversations.find((session)=>session.userId === userId && session.sessionId === sessionId) || null;\n}\nfunction createConversationSession(userId, sessionId) {\n    // First remove any old session for the same user/sessionId\n    const existingIndex = tempConversations.findIndex((session)=>session.userId === userId && session.sessionId === sessionId);\n    if (existingIndex !== -1) {\n        tempConversations.splice(existingIndex, 1);\n    }\n    const newSession = {\n        userId,\n        sessionId,\n        turns: [],\n        currentTopic: undefined,\n        currentSubject: undefined,\n        pendingTasks: [],\n        lastUpdate: new Date()\n    };\n    tempConversations.push(newSession);\n    console.log(\"\\uD83D\\uDCAC Created conversation session \".concat(sessionId, \" for user \").concat(userId));\n    return newSession;\n}\nfunction updateConversationSession(session) {\n    const index = tempConversations.findIndex((s)=>s.userId === session.userId && s.sessionId === session.sessionId);\n    if (index !== -1) {\n        tempConversations[index] = {\n            ...session,\n            lastUpdate: new Date()\n        };\n        console.log(\"\\uD83D\\uDCAC Updated session \".concat(session.sessionId, \" - \").concat(session.turns.length, \" turns\"));\n    } else {\n        tempConversations.push({\n            ...session,\n            lastUpdate: new Date()\n        });\n        console.log(\"\\uD83D\\uDCAC Created new session \".concat(session.sessionId, \" during update\"));\n    }\n    return session;\n}\nfunction addConversationTurn(userId, sessionId, role, content) {\n    let metadata = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};\n    let session = getConversationSession(userId, sessionId);\n    if (!session) {\n        session = createConversationSession(userId, sessionId);\n    }\n    const turn = {\n        id: \"turn_\".concat(Date.now(), \"_\").concat(Math.random().toString(36).substr(2, 9)),\n        timestamp: new Date(),\n        role,\n        content,\n        metadata\n    };\n    session.turns.push(turn);\n    // Keep only last 20 turns per session\n    if (session.turns.length > 20) {\n        session.turns = session.turns.slice(-20);\n    }\n    return updateConversationSession(session);\n}\nfunction addPendingTask(userId, sessionId, type, description, data) {\n    let session = getConversationSession(userId, sessionId);\n    if (!session) {\n        session = createConversationSession(userId, sessionId);\n    }\n    const task = {\n        id: \"task_\".concat(Date.now()),\n        type,\n        description,\n        data,\n        completed: false,\n        createdAt: new Date()\n    };\n    session.pendingTasks.push(task);\n    console.log(\"\\uD83D\\uDCCB Added pending task: \".concat(description));\n    updateConversationSession(session);\n}\nfunction markTaskCompleted(userId, sessionId, taskId, result) {\n    const session = getConversationSession(userId, sessionId);\n    if (!session) return false;\n    const task = session.pendingTasks.find((t)=>t.id === taskId);\n    if (!task) return false;\n    task.completed = true;\n    if (result) {\n        task.data.result = result;\n    }\n    console.log(\"✅ Completed task: \".concat(task.description));\n    updateConversationSession(session);\n    return true;\n}\nfunction getPendingTasks(userId, sessionId) {\n    const session = getConversationSession(userId, sessionId);\n    if (!session) return [];\n    return session.pendingTasks.filter((task)=>!task.completed);\n}\nfunction getConversationHistory(userId, sessionId) {\n    let limit = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 10;\n    const session = getConversationSession(userId, sessionId);\n    if (!session) return [];\n    return session.turns.slice(-limit);\n}\nfunction getUserActiveSessions(userId) {\n    const oneHourAgo = new Date(Date.now() - 60 * 60 * 1000);\n    return tempConversations.filter((session)=>session.userId === userId && session.lastUpdate > oneHourAgo);\n}\nfunction cleanupOldConversations() {\n    const sixHoursAgo = new Date(Date.now() - 6 * 60 * 60 * 1000);\n    const before = tempConversations.length;\n    // Remove conversations older than 6 hours\n    for(let i = tempConversations.length - 1; i >= 0; i--){\n        if (tempConversations[i].lastUpdate < sixHoursAgo) {\n            tempConversations.splice(i, 1);\n        }\n    }\n    const after = tempConversations.length;\n    if (before !== after) {\n        console.log(\"\\uD83E\\uDDF9 Cleaned up \".concat(before - after, \" old conversation sessions\"));\n    }\n}\n// Initialize default users automatically\n\nfunction initDefaultUsers() {\n    // Check if demo users already exist to avoid duplicates\n    const studentExists = findUserByEmail(\"estudiante@demo.com\");\n    const instructorExists = findUserByEmail(\"instructor@demo.com\");\n    if (!studentExists || !instructorExists) {\n        console.log(\"🔧 Inicializando usuarios por defecto...\");\n        try {\n            const hashedPassword = bcryptjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].hashSync(\"Estudiante123!!!\", 12);\n            // Only add student if doesn't exist\n            if (!studentExists) {\n                addUser({\n                    id: \"demo-student-fixed\",\n                    name: \"Estudiante Demo\",\n                    email: \"estudiante@demo.com\",\n                    password: hashedPassword,\n                    role: \"STUDENT\",\n                    studentId: \"EST-2025-001\",\n                    status: \"ACTIVE\",\n                    enrollmentYear: 2025,\n                    academicYear: \"2025-2026\",\n                    program: \"Ingeniería en Sistemas\",\n                    phoneNumber: \"+1234567890\",\n                    dateOfBirth: new Date(\"2000-01-01\"),\n                    address: \"Demo Address 123\",\n                    emergencyContact: {\n                        name: \"Contacto Demo\",\n                        phone: \"+0987654321\",\n                        relationship: \"Padre\"\n                    },\n                    createdAt: new Date(),\n                    updatedAt: new Date()\n                });\n                console.log(\"✅ Usuario estudiante demo creado\");\n            }\n            // Only add instructor if doesn't exist\n            if (!instructorExists) {\n                addUser({\n                    id: \"demo-instructor-fixed\",\n                    name: \"Instructor Demo\",\n                    email: \"instructor@demo.com\",\n                    password: hashedPassword,\n                    role: \"INSTRUCTOR\",\n                    studentId: null,\n                    status: \"ACTIVE\",\n                    enrollmentYear: 2025,\n                    academicYear: \"2025-2026\",\n                    createdAt: new Date(),\n                    updatedAt: new Date()\n                });\n                console.log(\"✅ Usuario instructor demo creado\");\n            }\n            console.log(\"✅ Verificación de usuarios por defecto completada\");\n        } catch (error) {\n            console.error(\"❌ Error creando usuarios por defecto:\", error);\n        }\n    } else {\n        console.log(\"✅ Usuarios demo ya existen, no se reinicializan\");\n    }\n    // Always check and initialize sample reports\n    initSampleReports();\n}\nfunction initSampleReports() {\n    // Check if sample reports already exist for demo student\n    const existingSampleReports = tempWeeklyReports.filter((report)=>report.userId === \"demo-student-fixed\");\n    if (existingSampleReports.length === 0) {\n        console.log(\"📝 Inicializando reportes de muestra...\");\n        try {\n            // Get current week dates\n            const now = new Date();\n            const currentWeek = getCurrentWeekStart();\n            const currentWeekEnd = getCurrentWeekEnd();\n            // Previous week\n            const prevWeek = new Date(currentWeek);\n            prevWeek.setDate(prevWeek.getDate() - 7);\n            const prevWeekEnd = new Date(currentWeekEnd);\n            prevWeekEnd.setDate(prevWeekEnd.getDate() - 7);\n            // Sample report from previous week\n            addWeeklyReport({\n                id: \"sample-report-1\",\n                userId: \"demo-student-fixed\",\n                weekStart: prevWeek,\n                weekEnd: prevWeekEnd,\n                submittedAt: new Date(prevWeekEnd.getTime() - 24 * 60 * 60 * 1000),\n                responses: {\n                    temasYDominio: \"Esta semana trabajamos con JavaScript básico - Nivel 3: Domino funciones y arrays, y estoy aprendiendo objetos complejos.\",\n                    evidenciaAprendizaje: \"Completé un proyecto de To-Do List usando JavaScript vanilla. Implementé funciones para agregar, editar y eliminar tareas usando arrays y objetos.\",\n                    dificultadesEstrategias: \"Tuve dificultades con el manejo de eventos en JavaScript. Lo resolví practicando con ejemplos y consultando documentación de MDN.\",\n                    conexionesAplicacion: \"Los conceptos de eventos se conectan con la interactividad en aplicaciones web. Puedo aplicarlo para crear interfaces más dinámicas.\",\n                    comentariosAdicionales: \"Me siento más confiado con JavaScript. Quiero seguir practicando con proyectos más complejos.\"\n                }\n            });\n            // Two weeks ago report  \n            const twoWeeksAgo = new Date(currentWeek);\n            twoWeeksAgo.setDate(twoWeeksAgo.getDate() - 14);\n            const twoWeeksAgoEnd = new Date(currentWeekEnd);\n            twoWeeksAgoEnd.setDate(twoWeeksAgoEnd.getDate() - 14);\n            addWeeklyReport({\n                id: \"sample-report-2\",\n                userId: \"demo-student-fixed\",\n                weekStart: twoWeeksAgo,\n                weekEnd: twoWeeksAgoEnd,\n                submittedAt: new Date(twoWeeksAgoEnd.getTime() - 12 * 60 * 60 * 1000),\n                responses: {\n                    temasYDominio: \"Esta semana estudiamos CSS Grid y Flexbox - Nivel 2: Entiendo los conceptos básicos pero aún tengo dudas con layouts complejos.\",\n                    evidenciaAprendizaje: \"Recreé el layout de una página web usando CSS Grid. Logré hacer una estructura responsive con header, sidebar y main content.\",\n                    dificultadesEstrategias: \"Me confundí con las propiedades grid-template-areas. Resolví el problema dibujando el layout en papel primero.\",\n                    conexionesAplicacion: \"CSS Grid es perfecto para crear layouts de páginas web modernas. Lo usaré en mi proyecto final de página portfolio.\",\n                    comentariosAdicionales: \"CSS es más divertido de lo que pensaba. Me gusta ver los resultados visuales inmediatos.\"\n                }\n            });\n            console.log(\"✅ Reportes de muestra creados exitosamente\");\n        } catch (error) {\n            console.error(\"❌ Error creando reportes de muestra:\", error);\n        }\n    } else {\n        console.log(\"✅ Reportes de muestra ya existen, no se reinicializan\");\n    }\n}\n// Initialize on module load\ninitDefaultUsers();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvdGVtcC1zdG9yYWdlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsdURBQXVEO0FBd0R2RCxvREFBb0Q7QUFDcEQsTUFBTUEsbUJBQW1CQztJQUtZRDtBQUE5QixNQUFNRSxZQUF3QkYsQ0FBQUEsOEJBQUFBLGlCQUFpQkUsU0FBUyxjQUExQkYseUNBQUFBLDhCQUE4QixFQUFFO0lBQ3BCQTtBQUExQyxNQUFNRyxvQkFBb0NILENBQUFBLHNDQUFBQSxpQkFBaUJHLGlCQUFpQixjQUFsQ0gsaURBQUFBLHNDQUFzQyxFQUFFO0FBRXpGLGtEQUFrRDtBQUNsREEsaUJBQWlCRSxTQUFTLEdBQUdBO0FBQzdCRixpQkFBaUJHLGlCQUFpQixHQUFHQTtBQUU5QixTQUFTQyxRQUFRQyxJQUFjO0lBQ3BDSCxVQUFVSSxJQUFJLENBQUNEO0FBQ2pCO0FBRU8sU0FBU0UsZ0JBQWdCQyxLQUFhO0lBQzNDLE9BQU9OLFVBQVVPLElBQUksQ0FBQ0osQ0FBQUEsT0FBUUEsS0FBS0csS0FBSyxLQUFLQTtBQUMvQztBQUVPLFNBQVNFLG9CQUFvQkMsU0FBaUI7SUFDbkQsT0FBT1QsVUFBVU8sSUFBSSxDQUFDSixDQUFBQSxPQUFRQSxLQUFLTSxTQUFTLEtBQUtBO0FBQ25EO0FBRU8sU0FBU0MsYUFBYUMsRUFBVTtJQUNyQyxPQUFPWCxVQUFVTyxJQUFJLENBQUNKLENBQUFBLE9BQVFBLEtBQUtRLEVBQUUsS0FBS0E7QUFDNUM7QUFFTyxTQUFTQztJQUNkLE9BQU9aO0FBQ1Q7QUFFTyxTQUFTYSxnQkFBZ0JDLElBQVk7SUFDMUMsT0FBT2QsVUFBVWUsTUFBTSxDQUFDWixDQUFBQSxPQUFRQSxLQUFLVyxJQUFJLEtBQUtBO0FBQ2hEO0FBRU8sU0FBU0UsbUJBQW1CQyxPQUFlO0lBQ2hELE9BQU9qQixVQUFVZSxNQUFNLENBQUNaLENBQUFBLE9BQVFBLEtBQUtjLE9B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Y0FBYyxJQUFJN0osS0FBS2tKO1lBQzdCVyxZQUFZckgsT0FBTyxDQUFDcUgsWUFBWXRILE9BQU8sS0FBSztZQUM1QyxNQUFNdUgsaUJBQWlCLElBQUk5SixLQUFLbUo7WUFDaENXLGVBQWV0SCxPQUFPLENBQUNzSCxlQUFldkgsT0FBTyxLQUFLO1lBRWxEbEIsZ0JBQWdCO2dCQUNkbkMsSUFBSTtnQkFDSnNDLFFBQVE7Z0JBQ1JFLFdBQVdtSTtnQkFDWDdILFNBQVM4SDtnQkFDVFIsYUFBYSxJQUFJdEosS0FBSzhKLGVBQWVuSSxPQUFPLEtBQUssS0FBSyxLQUFLLEtBQUs7Z0JBQ2hFNEgsV0FBVztvQkFDVEMsZUFBZTtvQkFDZkMsc0JBQXNCO29CQUN0QkMseUJBQXlCO29CQUN6QkMsc0JBQXNCO29CQUN0QkMsd0JBQXdCO2dCQUMxQjtZQUNGO1lBRUE3RyxRQUFRQyxHQUFHLENBQUM7UUFDZCxFQUFFLE9BQU9vQixPQUFPO1lBQ2RyQixRQUFRcUIsS0FBSyxDQUFDLHdDQUF3Q0E7UUFDeEQ7SUFDRixPQUFPO1FBQ0xyQixRQUFRQyxHQUFHLENBQUM7SUFDZDtBQUNGO0FBRUEsNEJBQTRCO0FBQzVCaUYiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yb2RyaWdvZGliZXJuYXJkbzMzZ21haWwuY29tL0RvY3VtZW50cy9BcHAgRGV2ZWxvcG1lbnQgUHJveWVjdHMvSW50ZWxsZWdvIFBsYXRmb3JtL3NyYy9saWIvdGVtcC1zdG9yYWdlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFRlbXBvcmFyeSB1c2VyIHN0b3JhZ2UgLSByZXBsYWNlIHdpdGggZGF0YWJhc2UgbGF0ZXJcbmludGVyZmFjZSBUZW1wVXNlciB7XG4gIGlkOiBzdHJpbmdcbiAgbmFtZTogc3RyaW5nXG4gIGVtYWlsOiBzdHJpbmdcbiAgcGFzc3dvcmQ6IHN0cmluZ1xuICBzdHVkZW50SWQ/OiBzdHJpbmcgfCBudWxsXG4gIHJvbGU6IHN0cmluZ1xuICBjcmVhdGVkQXQ6IERhdGVcbiAgdXBkYXRlZEF0OiBEYXRlXG4gIGltYWdlPzogc3RyaW5nXG4gIC8vIEFjYWRlbWljIGZpZWxkc1xuICBwcm9ncmFtPzogc3RyaW5nIC8vIENhcnJlcmEvcHJvZ3JhbWEgZGUgZXN0dWRpb3NcbiAgYWNhZGVtaWNZZWFyPzogc3RyaW5nIC8vIEHDsW8gYWNhZMOpbWljbyAoZWo6IFwiMjAyNC0yMDI1XCIpXG4gIGVucm9sbG1lbnRZZWFyPzogbnVtYmVyIC8vIEHDsW8gZGUgaW5ncmVzb1xuICBzdGF0dXM/OiBcIkFDVElWRVwiIHwgXCJJTkFDVElWRVwiIHwgXCJTVVNQRU5ERURcIiAvLyBFc3RhZG8gZGVsIGVzdHVkaWFudGVcbiAgcGhvbmVOdW1iZXI/OiBzdHJpbmdcbiAgZGF0ZU9mQmlydGg/OiBEYXRlXG4gIGFkZHJlc3M/OiBzdHJpbmdcbiAgZW1lcmdlbmN5Q29udGFjdD86IHtcbiAgICBuYW1lOiBzdHJpbmdcbiAgICBwaG9uZTogc3RyaW5nXG4gICAgcmVsYXRpb25zaGlwOiBzdHJpbmdcbiAgfVxuICBwcmVmZXJlbmNlcz86IHtcbiAgICBlbWFpbE5vdGlmaWNhdGlvbnM6IGJvb2xlYW5cbiAgICBwdXNoTm90aWZpY2F0aW9uczogYm9vbGVhblxuICAgIHdlZWtseVJlbWluZGVyczogYm9vbGVhblxuICAgIHByb2dyZXNzUmVwb3J0czogYm9vbGVhblxuICB9XG59XG5cbmludGVyZmFjZSBBdHRhY2hlZEZpbGUge1xuICBmaWxlbmFtZTogc3RyaW5nXG4gIG9yaWdpbmFsTmFtZTogc3RyaW5nXG4gIHNpemU6IG51bWJlclxuICB0eXBlOiBzdHJpbmdcbiAgdXJsOiBzdHJpbmdcbn1cblxuaW50ZXJmYWNlIFdlZWtseVJlcG9ydCB7XG4gIGlkOiBzdHJpbmdcbiAgdXNlcklkOiBzdHJpbmdcbiAgd2Vla1N0YXJ0OiBEYXRlXG4gIHdlZWtFbmQ6IERhdGVcbiAgc3VibWl0dGVkQXQ6IERhdGVcbiAgcmVzcG9uc2VzOiB7XG4gICAgdGVtYXNZRG9taW5pbzogc3RyaW5nIC8vIFByZWd1bnRhIDFcbiAgICBldmlkZW5jaWFBcHJlbmRpemFqZTogc3RyaW5nIC8vIFByZWd1bnRhIDJcbiAgICBkaWZpY3VsdGFkZXNFc3RyYXRlZ2lhczogc3RyaW5nIC8vIFByZWd1bnRhIDNcbiAgICBjb25leGlvbmVzQXBsaWNhY2lvbjogc3RyaW5nIC8vIFByZWd1bnRhIDRcbiAgICBjb21lbnRhcmlvc0FkaWNpb25hbGVzPzogc3RyaW5nIC8vIFByZWd1bnRhIDUgKG9wY2lvbmFsKVxuICB9XG4gIGF0dGFjaG1lbnRzPzogQXR0YWNoZWRGaWxlW10gLy8gQXJjaGl2b3MgYWRqdW50b3Ncbn1cblxuLy8gU2luZ2xldG9uIHBhdHRlcm4gdG8gcGVyc2lzdCBkYXRhIGFjcm9zcyByZXF1ZXN0c1xuY29uc3QgZ2xvYmFsRm9yU3RvcmFnZSA9IGdsb2JhbFRoaXMgYXMgdW5rbm93biBhcyB7XG4gIHRlbXBVc2VyczogVGVtcFVzZXJbXSB8IHVuZGVmaW5lZFxuICB0ZW1wV2Vla2x5UmVwb3J0czogV2Vla2x5UmVwb3J0W10gfCB1bmRlZmluZWRcbn1cblxuZXhwb3J0IGNvbnN0IHRlbXBVc2VyczogVGVtcFVzZXJbXSA9IGdsb2JhbEZvclN0b3JhZ2UudGVtcFVzZXJzID8/IFtdXG5leHBvcnQgY29uc3QgdGVtcFdlZWtseVJlcG9ydHM6IFdlZWtseVJlcG9ydFtdID0gZ2xvYmFsRm9yU3RvcmFnZS50ZW1wV2Vla2x5UmVwb3J0cyA/PyBbXVxuXG4vLyBBc3NpZ24gdG8gZ2xvYmFsVGhpcyB0byBwZXJzaXN0IGFjcm9zcyByZXF1ZXN0c1xuZ2xvYmFsRm9yU3RvcmFnZS50ZW1wVXNlcnMgPSB0ZW1wVXNlcnNcbmdsb2JhbEZvclN0b3JhZ2UudGVtcFdlZWtseVJlcG9ydHMgPSB0ZW1wV2Vla2x5UmVwb3J0c1xuXG5leHBvcnQgZnVuY3Rpb24gYWRkVXNlcih1c2VyOiBUZW1wVXNlcikge1xuICB0ZW1wVXNlcnMucHVzaCh1c2VyKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZmluZFVzZXJCeUVtYWlsKGVtYWlsOiBzdHJpbmcpIHtcbiAgcmV0dXJuIHRlbXBVc2Vycy5maW5kKHVzZXIgPT4gdXNlci5lbWFpbCA9PT0gZW1haWwpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmaW5kVXNlckJ5U3R1ZGVudElkKHN0dWRlbnRJZDogc3RyaW5nKSB7XG4gIHJldHVybiB0ZW1wVXNlcnMuZmluZCh1c2VyID0+IHVzZXIuc3R1ZGVudElkID09PSBzdHVkZW50SWQpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmaW5kVXNlckJ5SWQoaWQ6IHN0cmluZykge1xuICByZXR1cm4gdGVtcFVzZXJzLmZpbmQodXNlciA9PiB1c2VyLmlkID09PSBpZClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEFsbFVzZXJzKCkge1xuICByZXR1cm4gdGVtcFVzZXJzXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmaW5kVXNlcnNCeVJvbGUocm9sZTogc3RyaW5nKSB7XG4gIHJldHVybiB0ZW1wVXNlcnMuZmlsdGVyKHVzZXIgPT4gdXNlci5yb2xlID09PSByb2xlKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZmluZFVzZXJzQnlQcm9ncmFtKHByb2dyYW06IHN0cmluZykge1xuICByZXR1cm4gdGVtcFVzZXJzLmZpbHRlcih1c2VyID0+IHVzZXIucHJvZ3JhbSA9PT0gcHJvZ3JhbSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRVc2Vyc0J5U3RhdHVzKHN0YXR1czogXCJBQ1RJVkVcIiB8IFwiSU5BQ1RJVkVcIiB8IFwiU1VTUEVOREVEXCIpIHtcbiAgcmV0dXJuIHRlbXBVc2Vycy5maWx0ZXIodXNlciA9PiB1c2VyLnN0YXR1cyA9PT0gc3RhdHVzKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlVXNlcihpZDogc3RyaW5nLCB1cGRhdGVzOiBQYXJ0aWFsPFRlbXBVc2VyPikge1xuICBjb25zdCB1c2VySW5kZXggPSB0ZW1wVXNlcnMuZmluZEluZGV4KHVzZXIgPT4gdXNlci5pZCA9PT0gaWQpXG4gIGlmICh1c2VySW5kZXggIT09IC0xKSB7XG4gICAgdGVtcFVzZXJzW3VzZXJJbmRleF0gPSB7XG4gICAgICAuLi50ZW1wVXNlcnNbdXNlckluZGV4XSxcbiAgICAgIC4uLnVwZGF0ZXMsXG4gICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKClcbiAgICB9XG4gICAgcmV0dXJuIHRlbXBVc2Vyc1t1c2VySW5kZXhdXG4gIH1cbiAgcmV0dXJuIG51bGxcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlbGV0ZVVzZXIoaWQ6IHN0cmluZykge1xuICBjb25zdCB1c2VySW5kZXggPSB0ZW1wVXNlcnMuZmluZEluZGV4KHVzZXIgPT4gdXNlci5pZCA9PT0gaWQpXG4gIGlmICh1c2VySW5kZXggIT09IC0xKSB7XG4gICAgcmV0dXJuIHRlbXBVc2Vycy5zcGxpY2UodXNlckluZGV4LCAxKVswXVxuICB9XG4gIHJldHVybiBudWxsXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZVN0dWRlbnRJZChzdHVkZW50SWQ6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAvLyBGb3JtYXRvIHN1Z2VyaWRvOiBFU1QtWVlZWS1YWFggKGVqOiBFU1QtMjAyNC0wMDEpXG4gIGNvbnN0IHN0dWRlbnRJZFJlZ2V4ID0gL15FU1QtXFxkezR9LVxcZHszfSQvXG4gIHJldHVybiBzdHVkZW50SWRSZWdleC50ZXN0KHN0dWRlbnRJZClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlU3R1ZGVudElkKCk6IHN0cmluZyB7XG4gIGNvbnN0IGN1cnJlbnRZZWFyID0gbmV3IERhdGUoKS5nZXRGdWxsWWVhcigpXG4gIGNvbnN0IGV4aXN0aW5nSWRzID0gdGVtcFVzZXJzXG4gICAgLmZpbHRlcih1c2VyID0+IHVzZXIuc3R1ZGVudElkICYmIHVzZXIuc3R1ZGVudElkLnN0YXJ0c1dpdGgoYEVTVC0ke2N1cnJlbnRZZWFyfWApKVxuICAgIC5tYXAodXNlciA9PiB1c2VyLnN0dWRlbnRJZCEpXG4gICAgLnNvcnQoKVxuXG4gIGxldCBuZXh0TnVtYmVyID0gMVxuICBpZiAoZXhpc3RpbmdJZHMubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IGxhc3RJZCA9IGV4aXN0aW5nSWRzW2V4aXN0aW5nSWRzLmxlbmd0aCAtIDFdXG4gICAgY29uc3QgbGFzdE51bWJlciA9IHBhcnNlSW50KGxhc3RJZC5zcGxpdCgnLScpWzJdKVxuICAgIG5leHROdW1iZXIgPSBsYXN0TnVtYmVyICsgMVxuICB9XG5cbiAgcmV0dXJuIGBFU1QtJHtjdXJyZW50WWVhcn0tJHtuZXh0TnVtYmVyLnRvU3RyaW5nKCkucGFkU3RhcnQoMywgJzAnKX1gXG59XG5cbi8vIFdlZWtseSBSZXBvcnRzIEZ1bmN0aW9uc1xuZXhwb3J0IGZ1bmN0aW9uIGFkZFdlZWtseVJlcG9ydChyZXBvcnQ6IFdlZWtseVJlcG9ydCkge1xuICB0ZW1wV2Vla2x5UmVwb3J0cy5wdXNoKHJlcG9ydClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRXZWVrbHlSZXBvcnRzQnlVc2VyKHVzZXJJZDogc3RyaW5nKTogV2Vla2x5UmVwb3J0W10ge1xuICByZXR1cm4gdGVtcFdlZWtseVJlcG9ydHMuZmlsdGVyKHJlcG9ydCA9PiByZXBvcnQudXNlcklkID09PSB1c2VySWQpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmaW5kV2Vla2x5UmVwb3J0QnlVc2VyQW5kV2Vlayh1c2VySWQ6IHN0cmluZywgd2Vla1N0YXJ0OiBEYXRlKTogV2Vla2x5UmVwb3J0IHwgdW5kZWZpbmVkIHtcbiAgcmV0dXJuIHRlbXBXZWVrbHlSZXBvcnRzLmZpbmQocmVwb3J0ID0+IFxuICAgIHJlcG9ydC51c2VySWQgPT09IHVzZXJJZCAmJiBcbiAgICByZXBvcnQud2Vla1N0YXJ0LmdldFRpbWUoKSA9PT0gd2Vla1N0YXJ0LmdldFRpbWUoKVxuICApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRBbGxXZWVrbHlSZXBvcnRzKCk6IFdlZWtseVJlcG9ydFtdIHtcbiAgcmV0dXJuIHRlbXBXZWVrbHlSZXBvcnRzXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRXZWVrbHlSZXBvcnRzQnlEYXRlUmFuZ2Uoc3RhcnREYXRlOiBEYXRlLCBlbmREYXRlOiBEYXRlKTogV2Vla2x5UmVwb3J0W10ge1xuICByZXR1cm4gdGVtcFdlZWtseVJlcG9ydHMuZmlsdGVyKHJlcG9ydCA9PiBcbiAgICByZXBvcnQud2Vla1N0YXJ0ID49IHN0YXJ0RGF0ZSAmJiByZXBvcnQud2Vla0VuZCA8PSBlbmREYXRlXG4gIClcbn1cblxuLy8gRGF0ZSB1dGlsaXR5IGZ1bmN0aW9uc1xuZXhwb3J0IGZ1bmN0aW9uIGdldEN1cnJlbnRXZWVrU3RhcnQoKTogRGF0ZSB7XG4gIGNvbnN0IG5vdyA9IG5ldyBEYXRlKClcbiAgY29uc3QgbW9uZGF5ID0gbmV3IERhdGUobm93KVxuICBjb25zdCBkYXkgPSBub3cuZ2V0RGF5KClcbiAgY29uc3QgZGlmZiA9IG5vdy5nZXREYXRlKCkgLSBkYXkgKyAoZGF5ID09PSAwID8gLTYgOiAxKSAvLyBBZGp1c3QgZm9yIFN1bmRheVxuICBtb25kYXkuc2V0RGF0ZShkaWZmKVxuICBtb25kYXkuc2V0SG91cnMoMCwgMCwgMCwgMClcbiAgcmV0dXJuIG1vbmRheVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q3VycmVudFdlZWtFbmQoKTogRGF0ZSB7XG4gIGNvbnN0IHdlZWtTdGFydCA9IGdldEN1cnJlbnRXZWVrU3RhcnQoKVxuICBjb25zdCB3ZWVrRW5kID0gbmV3IERhdGUod2Vla1N0YXJ0KVxuICB3ZWVrRW5kLnNldERhdGUod2Vla1N0YXJ0LmdldERhdGUoKSArIDYpXG4gIHdlZWtFbmQuc2V0SG91cnMoMjMsIDU5LCA1OSwgOTk5KVxuICByZXR1cm4gd2Vla0VuZFxufVxuXG5leHBvcnQgZnVuY3Rpb24gY2FuU3VibWl0VGhpc1dlZWsodXNlcklkOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgY29uc3Qgd2Vla1N0YXJ0ID0gZ2V0Q3VycmVudFdlZWtTdGFydCgpXG4gIGNvbnN0IHdlZWtFbmQgPSBnZXRDdXJyZW50V2Vla0VuZCgpXG4gIGNvbnN0IGN1cnJlbnREYXRlID0gbmV3IERhdGUoKVxuICBjb25zdCBleGlzdGluZ1JlcG9ydCA9IGZpbmRXZWVrbHlSZXBvcnRCeVVzZXJBbmRXZWVrKHVzZXJJZCwgd2Vla1N0YXJ0KVxuICBcbiAgLy8gQ2FuIHN1Ym1pdCBpZjpcbiAgLy8gMS4gV2UgYXJlIGN1cnJlbnRseSBpbiB0aGlzIHdlZWsgKGN1cnJlbnREYXRlIGlzIGJldHdlZW4gd2Vla1N0YXJ0IGFuZCB3ZWVrRW5kKVxuICAvLyAyLiBObyByZXBvcnQgZXhpc3RzIGZvciB0aGlzIHdlZWtcbiAgY29uc3QgaXNDdXJyZW50V2VlayA9IGN1cnJlbnREYXRlID49IHdlZWtTdGFydCAmJiBjdXJyZW50RGF0ZSA8PSB3ZWVrRW5kXG4gIFxuICBjb25zb2xlLmxvZyhg8J+UjSBEZWJ1ZyBjYW5TdWJtaXRUaGlzV2VlayBmb3IgdXNlciAke3VzZXJJZH06YClcbiAgY29uc29sZS5sb2coYCAgQ3VycmVudCBkYXRlOiAke2N1cnJlbnREYXRlLnRvSVNPU3RyaW5nKCl9YClcbiAgY29uc29sZS5sb2coYCAgV2VlayBzdGFydDogJHt3ZWVrU3RhcnQudG9JU09TdHJpbmcoKX1gKVxuICBjb25zb2xlLmxvZyhgICBXZWVrIGVuZDogJHt3ZWVrRW5kLnRvSVNPU3RyaW5nKCl9YClcbiAgY29uc29sZS5sb2coYCAgSXMgY3VycmVudCB3ZWVrOiAke2lzQ3VycmVudFdlZWt9YClcbiAgY29uc29sZS5sb2coYCAgRXhpc3RpbmcgcmVwb3J0OiAke2V4aXN0aW5nUmVwb3J0ID8gJ1lFUycgOiAnTk8nfWApXG4gIGNvbnNvbGUubG9nKGAgIENhbiBzdWJtaXQ6ICR7aXNDdXJyZW50V2VlayAmJiAhZXhpc3RpbmdSZXBvcnR9YClcbiAgXG4gIHJldHVybiBpc0N1cnJlbnRXZWVrICYmICFleGlzdGluZ1JlcG9ydFxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0V2Vla0RhdGVzKGRhdGU6IERhdGUpOiB7IHN0YXJ0OiBEYXRlOyBlbmQ6IERhdGUgfSB7XG4gIGNvbnN0IHN0YXJ0ID0gbmV3IERhdGUoZGF0ZSlcbiAgY29uc3QgZGF5ID0gc3RhcnQuZ2V0RGF5KClcbiAgY29uc3QgZGlmZiA9IHN0YXJ0LmdldERhdGUoKSAtIGRheSArIChkYXkgPT09IDAgPyAtNiA6IDEpXG4gIHN0YXJ0LnNldERhdGUoZGlmZilcbiAgc3RhcnQuc2V0SG91cnMoMCwgMCwgMCwgMClcbiAgXG4gIGNvbnN0IGVuZCA9IG5ldyBEYXRlKHN0YXJ0KVxuICBlbmQuc2V0RGF0ZShzdGFydC5nZXREYXRlKCkgKyA2KVxuICBlbmQuc2V0SG91cnMoMjMsIDU5LCA1OSwgOTk5KVxuICBcbiAgcmV0dXJuIHsgc3RhcnQsIGVuZCB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRNb250aFdlZWtzKHllYXI6IG51bWJlciwgbW9udGg6IG51bWJlcik6IEFycmF5PHsgc3RhcnQ6IERhdGU7IGVuZDogRGF0ZSB9PiB7XG4gIGNvbnN0IHdlZWtzID0gW11cbiAgY29uc3QgZmlyc3REYXkgPSBuZXcgRGF0ZSh5ZWFyLCBtb250aCwgMSlcbiAgY29uc3QgbGFzdERheSA9IG5ldyBEYXRlKHllYXIsIG1vbnRoICsgMSwgMClcbiAgXG4gIGxldCBjdXJyZW50ID0gbmV3IERhdGUoZmlyc3REYXkpXG4gIFxuICAvLyBBZGp1c3QgdG8gc3RhcnQgZnJvbSBNb25kYXkgb2YgZmlyc3Qgd2Vla1xuICBjb25zdCBkYXlPZldlZWsgPSBjdXJyZW50LmdldERheSgpXG4gIGNvbnN0IGRheXNUb1N1YnRyYWN0ID0gZGF5T2ZXZWVrID09PSAwID8gNiA6IGRheU9mV2VlayAtIDFcbiAgY3VycmVudC5zZXREYXRlKGN1cnJlbnQuZ2V0RGF0ZSgpIC0gZGF5c1RvU3VidHJhY3QpXG4gIFxuICB3aGlsZSAoY3VycmVudCA8PSBsYXN0RGF5KSB7XG4gICAgY29uc3Qgd2Vla1N0YXJ0ID0gbmV3IERhdGUoY3VycmVudClcbiAgICBjb25zdCB3ZWVrRW5kID0gbmV3IERhdGUoY3VycmVudClcbiAgICB3ZWVrRW5kLnNldERhdGUod2Vla1N0YXJ0LmdldERhdGUoKSArIDYpXG4gICAgXG4gICAgd2Vla3MucHVzaCh7IHN0YXJ0OiB3ZWVrU3RhcnQsIGVuZDogd2Vla0VuZCB9KVxuICAgIGN1cnJlbnQuc2V0RGF0ZShjdXJyZW50LmdldERhdGUoKSArIDcpXG4gIH1cbiAgXG4gIHJldHVybiB3ZWVrc1xufVxuXG4vLyA9PT09PSBDQUxFTkRBUiBGVU5DVElPTlMgPT09PT1cbi8vIFRoZXNlIGZ1bmN0aW9ucyBpbnRlZ3JhdGUgd2l0aCB0aGUgY2FsZW5kYXIgc3lzdGVtIGZvciBTYXJhIEFJXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRFdmVudHModXNlcklkOiBzdHJpbmcpOiBhbnlbXSB7XG4gIC8vIEltcG9ydCBjYWxlbmRhciBkYXRhIGZ1bmN0aW9uc1xuICB0cnkge1xuICAgIGNvbnN0IHsgZ2V0VXNlckNhbGVuZGFyRGF0YSB9ID0gcmVxdWlyZSgnLi9jYWxlbmRhci1kYXRhJylcbiAgICBjb25zdCB1c2VyRGF0YSA9IGdldFVzZXJDYWxlbmRhckRhdGEodXNlcklkKVxuICAgIHJldHVybiB1c2VyRGF0YT8uZXZlbnRzIHx8IFtdXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyBjYWxlbmRhciBldmVudHM6JywgZXJyb3IpXG4gICAgcmV0dXJuIFtdXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEFsbENhbGVuZGFyRXZlbnRzKHVzZXJJZDogc3RyaW5nKTogYW55W10ge1xuICAvLyBBbGlhcyBmb3IgZ2V0RXZlbnRzIGZvciBjb21wYXRpYmlsaXR5XG4gIHJldHVybiBnZXRFdmVudHModXNlcklkKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VXBjb21pbmdFdmVudHModXNlcklkOiBzdHJpbmcsIGRheXM6IG51bWJlciA9IDMwKTogYW55W10ge1xuICB0cnkge1xuICAgIGNvbnN0IGFsbEV2ZW50cyA9IGdldEV2ZW50cyh1c2VySWQpXG4gICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKVxuICAgIGNvbnN0IGZ1dHVyZURhdGUgPSBuZXcgRGF0ZSgpXG4gICAgZnV0dXJlRGF0ZS5zZXREYXRlKGZ1dHVyZURhdGUuZ2V0RGF0ZSgpICsgZGF5cylcbiAgICBcbiAgICByZXR1cm4gYWxsRXZlbnRzLmZpbHRlcihldmVudCA9PiB7XG4gICAgICBjb25zdCBldmVudERhdGUgPSBuZXcgRGF0ZShldmVudC5kYXRlKVxuICAgICAgcmV0dXJuIGV2ZW50RGF0ZSA+PSBub3cgJiYgZXZlbnREYXRlIDw9IGZ1dHVyZURhdGVcbiAgICB9KS5zb3J0KChhLCBiKSA9PiBuZXcgRGF0ZShhLmRhdGUpLmdldFRpbWUoKSAtIG5ldyBEYXRlKGIuZGF0ZSkuZ2V0VGltZSgpKVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgdXBjb21pbmcgZXZlbnRzOicsIGVycm9yKVxuICAgIHJldHVybiBbXVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRFdmVudHNGb3JEYXRlUmFuZ2UodXNlcklkOiBzdHJpbmcsIHN0YXJ0RGF0ZTogRGF0ZSwgZW5kRGF0ZTogRGF0ZSk6IGFueVtdIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBhbGxFdmVudHMgPSBnZXRFdmVudHModXNlcklkKVxuICAgIHJldHVybiBhbGxFdmVudHMuZmlsdGVyKGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IGV2ZW50RGF0ZSA9IG5ldyBEYXRlKGV2ZW50LmRhdGUpXG4gICAgICByZXR1cm4gZXZlbnREYXRlID49IHN0YXJ0RGF0ZSAmJiBldmVudERhdGUgPD0gZW5kRGF0ZVxuICAgIH0pXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyBldmVudHMgZm9yIGRhdGUgcmFuZ2U6JywgZXJyb3IpXG4gICAgcmV0dXJuIFtdXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRFdmVudEJ5SWQodXNlcklkOiBzdHJpbmcsIGV2ZW50SWQ6IHN0cmluZyk6IGFueSB8IG51bGwge1xuICB0cnkge1xuICAgIGNvbnN0IGFsbEV2ZW50cyA9IGdldEV2ZW50cyh1c2VySWQpXG4gICAgcmV0dXJuIGFsbEV2ZW50cy5maW5kKGV2ZW50ID0+IGV2ZW50LmlkID09PSBldmVudElkKSB8fCBudWxsXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZmluZGluZyBldmVudCBieSBJRDonLCBlcnJvcilcbiAgICByZXR1cm4gbnVsbFxuICB9XG59XG5cbi8vID09PT09IENPTlZFUlNBVElPTiBNRU1PUlkgRlVOQ1RJT05TID09PT09XG4vLyBQZXJzaXN0ZW50IGNvbnZlcnNhdGlvbiBzdG9yYWdlIGZvciBTYXJhIEFJXG5cbmludGVyZmFjZSBDb252ZXJzYXRpb25UdXJuIHtcbiAgaWQ6IHN0cmluZ1xuICB0aW1lc3RhbXA6IERhdGVcbiAgcm9sZTogJ3VzZXInIHwgJ2Fzc2lzdGFudCdcbiAgY29udGVudDogc3RyaW5nXG4gIG1ldGFkYXRhOiB7XG4gICAgc3ViamVjdD86IHN0cmluZ1xuICAgIHRvcGljPzogc3RyaW5nXG4gICAgaW50ZW50aW9uPzogc3RyaW5nXG4gICAgdGFza0NvbXBsZXRlZD86IGJvb2xlYW5cbiAgICBldmVudENyZWF0ZWQ/OiBib29sZWFuXG4gIH1cbn1cblxuaW50ZXJmYWNlIENvbnZlcnNhdGlvblNlc3Npb24ge1xuICB1c2VySWQ6IHN0cmluZ1xuICBzZXNzaW9uSWQ6IHN0cmluZ1xuICB0dXJuczogQ29udmVyc2F0aW9uVHVybltdXG4gIGN1cnJlbnRUb3BpYz86IHN0cmluZ1xuICBjdXJyZW50U3ViamVjdD86IHN0cmluZ1xuICBwZW5kaW5nVGFza3M6IEFycmF5PHtcbiAgICBpZDogc3RyaW5nXG4gICAgdHlwZTogJ2NhbGVuZGFyX2V2ZW50JyB8ICdhY2FkZW1pY19zZWFyY2gnIHwgJ3JlbWluZGVyJ1xuICAgIGRlc2NyaXB0aW9uOiBzdHJpbmdcbiAgICBkYXRhOiBhbnlcbiAgICBjb21wbGV0ZWQ6IGJvb2xlYW5cbiAgICBjcmVhdGVkQXQ6IERhdGVcbiAgfT5cbiAgbGFzdFVwZGF0ZTogRGF0ZVxufVxuXG4vLyBHbG9iYWwgc3RvcmFnZSBmb3IgY29udmVyc2F0aW9uc1xuY29uc3QgZ2xvYmFsRm9yQ29udmVyc2F0aW9ucyA9IGdsb2JhbFRoaXMgYXMgdW5rbm93biBhcyB7XG4gIHRlbXBDb252ZXJzYXRpb25zOiBDb252ZXJzYXRpb25TZXNzaW9uW10gfCB1bmRlZmluZWRcbn1cblxuZXhwb3J0IGNvbnN0IHRlbXBDb252ZXJzYXRpb25zOiBDb252ZXJzYXRpb25TZXNzaW9uW10gPSBnbG9iYWxGb3JDb252ZXJzYXRpb25zLnRlbXBDb252ZXJzYXRpb25zID8/IFtdXG5nbG9iYWxGb3JDb252ZXJzYXRpb25zLnRlbXBDb252ZXJzYXRpb25zID0gdGVtcENvbnZlcnNhdGlvbnNcblxuZXhwb3J0IGZ1bmN0aW9uIGdldENvbnZlcnNhdGlvblNlc3Npb24odXNlcklkOiBzdHJpbmcsIHNlc3Npb25JZDogc3RyaW5nKTogQ29udmVyc2F0aW9uU2Vzc2lvbiB8IG51bGwge1xuICByZXR1cm4gdGVtcENvbnZlcnNhdGlvbnMuZmluZChzZXNzaW9uID0+IFxuICAgIHNlc3Npb24udXNlcklkID09PSB1c2VySWQgJiYgc2Vzc2lvbi5zZXNzaW9uSWQgPT09IHNlc3Npb25JZFxuICApIHx8IG51bGxcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNvbnZlcnNhdGlvblNlc3Npb24odXNlcklkOiBzdHJpbmcsIHNlc3Npb25JZDogc3RyaW5nKTogQ29udmVyc2F0aW9uU2Vzc2lvbiB7XG4gIC8vIEZpcnN0IHJlbW92ZSBhbnkgb2xkIHNlc3Npb24gZm9yIHRoZSBzYW1lIHVzZXIvc2Vzc2lvbklkXG4gIGNvbnN0IGV4aXN0aW5nSW5kZXggPSB0ZW1wQ29udmVyc2F0aW9ucy5maW5kSW5kZXgoc2Vzc2lvbiA9PiBcbiAgICBzZXNzaW9uLnVzZXJJZCA9PT0gdXNlcklkICYmIHNlc3Npb24uc2Vzc2lvbklkID09PSBzZXNzaW9uSWRcbiAgKVxuICBpZiAoZXhpc3RpbmdJbmRleCAhPT0gLTEpIHtcbiAgICB0ZW1wQ29udmVyc2F0aW9ucy5zcGxpY2UoZXhpc3RpbmdJbmRleCwgMSlcbiAgfVxuXG4gIGNvbnN0IG5ld1Nlc3Npb246IENvbnZlcnNhdGlvblNlc3Npb24gPSB7XG4gICAgdXNlcklkLFxuICAgIHNlc3Npb25JZCxcbiAgICB0dXJuczogW10sXG4gICAgY3VycmVudFRvcGljOiB1bmRlZmluZWQsXG4gICAgY3VycmVudFN1YmplY3Q6IHVuZGVmaW5lZCxcbiAgICBwZW5kaW5nVGFza3M6IFtdLFxuICAgIGxhc3RVcGRhdGU6IG5ldyBEYXRlKClcbiAgfVxuICBcbiAgdGVtcENvbnZlcnNhdGlvbnMucHVzaChuZXdTZXNzaW9uKVxuICBjb25zb2xlLmxvZyhg8J+SrCBDcmVhdGVkIGNvbnZlcnNhdGlvbiBzZXNzaW9uICR7c2Vzc2lvbklkfSBmb3IgdXNlciAke3VzZXJJZH1gKVxuICByZXR1cm4gbmV3U2Vzc2lvblxufVxuXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlQ29udmVyc2F0aW9uU2Vzc2lvbihzZXNzaW9uOiBDb252ZXJzYXRpb25TZXNzaW9uKTogQ29udmVyc2F0aW9uU2Vzc2lvbiB7XG4gIGNvbnN0IGluZGV4ID0gdGVtcENvbnZlcnNhdGlvbnMuZmluZEluZGV4KHMgPT4gXG4gICAgcy51c2VySWQgPT09IHNlc3Npb24udXNlcklkICYmIHMuc2Vzc2lvbklkID09PSBzZXNzaW9uLnNlc3Npb25JZFxuICApXG4gIFxuICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgdGVtcENvbnZlcnNhdGlvbnNbaW5kZXhdID0geyAuLi5zZXNzaW9uLCBsYXN0VXBkYXRlOiBuZXcgRGF0ZSgpIH1cbiAgICBjb25zb2xlLmxvZyhg8J+SrCBVcGRhdGVkIHNlc3Npb24gJHtzZXNzaW9uLnNlc3Npb25JZH0gLSAke3Nlc3Npb24udHVybnMubGVuZ3RofSB0dXJuc2ApXG4gIH0gZWxzZSB7XG4gICAgdGVtcENvbnZlcnNhdGlvbnMucHVzaCh7IC4uLnNlc3Npb24sIGxhc3RVcGRhdGU6IG5ldyBEYXRlKCkgfSlcbiAgICBjb25zb2xlLmxvZyhg8J+SrCBDcmVhdGVkIG5ldyBzZXNzaW9uICR7c2Vzc2lvbi5zZXNzaW9uSWR9IGR1cmluZyB1cGRhdGVgKVxuICB9XG4gIFxuICByZXR1cm4gc2Vzc2lvblxufVxuXG5leHBvcnQgZnVuY3Rpb24gYWRkQ29udmVyc2F0aW9uVHVybihcbiAgdXNlcklkOiBzdHJpbmcsIFxuICBzZXNzaW9uSWQ6IHN0cmluZywgXG4gIHJvbGU6ICd1c2VyJyB8ICdhc3Npc3RhbnQnLCBcbiAgY29udGVudDogc3RyaW5nLFxuICBtZXRhZGF0YTogQ29udmVyc2F0aW9uVHVyblsnbWV0YWRhdGEnXSA9IHt9XG4pOiBDb252ZXJzYXRpb25TZXNzaW9uIHtcbiAgbGV0IHNlc3Npb24gPSBnZXRDb252ZXJzYXRpb25TZXNzaW9uKHVzZXJJZCwgc2Vzc2lvbklkKVxuICBpZiAoIXNlc3Npb24pIHtcbiAgICBzZXNzaW9uID0gY3JlYXRlQ29udmVyc2F0aW9uU2Vzc2lvbih1c2VySWQsIHNlc3Npb25JZClcbiAgfVxuICBcbiAgY29uc3QgdHVybjogQ29udmVyc2F0aW9uVHVybiA9IHtcbiAgICBpZDogYHR1cm5fJHtEYXRlLm5vdygpfV8ke01hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCA5KX1gLFxuICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKSxcbiAgICByb2xlLFxuICAgIGNvbnRlbnQsXG4gICAgbWV0YWRhdGFcbiAgfVxuICBcbiAgc2Vzc2lvbi50dXJucy5wdXNoKHR1cm4pXG4gIFxuICAvLyBLZWVwIG9ubHkgbGFzdCAyMCB0dXJucyBwZXIgc2Vzc2lvblxuICBpZiAoc2Vzc2lvbi50dXJucy5sZW5ndGggPiAyMCkge1xuICAgIHNlc3Npb24udHVybnMgPSBzZXNzaW9uLnR1cm5zLnNsaWNlKC0yMClcbiAgfVxuICBcbiAgcmV0dXJuIHVwZGF0ZUNvbnZlcnNhdGlvblNlc3Npb24oc2Vzc2lvbilcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZFBlbmRpbmdUYXNrKFxuICB1c2VySWQ6IHN0cmluZyxcbiAgc2Vzc2lvbklkOiBzdHJpbmcsXG4gIHR5cGU6ICdjYWxlbmRhcl9ldmVudCcgfCAnYWNhZGVtaWNfc2VhcmNoJyB8ICdyZW1pbmRlcicsXG4gIGRlc2NyaXB0aW9uOiBzdHJpbmcsXG4gIGRhdGE6IGFueVxuKTogdm9pZCB7XG4gIGxldCBzZXNzaW9uID0gZ2V0Q29udmVyc2F0aW9uU2Vzc2lvbih1c2VySWQsIHNlc3Npb25JZClcbiAgaWYgKCFzZXNzaW9uKSB7XG4gICAgc2Vzc2lvbiA9IGNyZWF0ZUNvbnZlcnNhdGlvblNlc3Npb24odXNlcklkLCBzZXNzaW9uSWQpXG4gIH1cbiAgXG4gIGNvbnN0IHRhc2sgPSB7XG4gICAgaWQ6IGB0YXNrXyR7RGF0ZS5ub3coKX1gLFxuICAgIHR5cGUsXG4gICAgZGVzY3JpcHRpb24sXG4gICAgZGF0YSxcbiAgICBjb21wbGV0ZWQ6IGZhbHNlLFxuICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKVxuICB9XG4gIFxuICBzZXNzaW9uLnBlbmRpbmdUYXNrcy5wdXNoKHRhc2spXG4gIGNvbnNvbGUubG9nKGDwn5OLIEFkZGVkIHBlbmRpbmcgdGFzazogJHtkZXNjcmlwdGlvbn1gKVxuICBcbiAgdXBkYXRlQ29udmVyc2F0aW9uU2Vzc2lvbihzZXNzaW9uKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbWFya1Rhc2tDb21wbGV0ZWQoXG4gIHVzZXJJZDogc3RyaW5nLFxuICBzZXNzaW9uSWQ6IHN0cmluZyxcbiAgdGFza0lkOiBzdHJpbmcsXG4gIHJlc3VsdD86IGFueVxuKTogYm9vbGVhbiB7XG4gIGNvbnN0IHNlc3Npb24gPSBnZXRDb252ZXJzYXRpb25TZXNzaW9uKHVzZXJJZCwgc2Vzc2lvbklkKVxuICBpZiAoIXNlc3Npb24pIHJldHVybiBmYWxzZVxuICBcbiAgY29uc3QgdGFzayA9IHNlc3Npb24ucGVuZGluZ1Rhc2tzLmZpbmQodCA9PiB0LmlkID09PSB0YXNrSWQpXG4gIGlmICghdGFzaykgcmV0dXJuIGZhbHNlXG4gIFxuICB0YXNrLmNvbXBsZXRlZCA9IHRydWVcbiAgaWYgKHJlc3VsdCkge1xuICAgIHRhc2suZGF0YS5yZXN1bHQgPSByZXN1bHRcbiAgfVxuICBcbiAgY29uc29sZS5sb2coYOKchSBDb21wbGV0ZWQgdGFzazogJHt0YXNrLmRlc2NyaXB0aW9ufWApXG4gIHVwZGF0ZUNvbnZlcnNhdGlvblNlc3Npb24oc2Vzc2lvbilcbiAgcmV0dXJuIHRydWVcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFBlbmRpbmdUYXNrcyh1c2VySWQ6IHN0cmluZywgc2Vzc2lvbklkOiBzdHJpbmcpOiBBcnJheTx7XG4gIGlkOiBzdHJpbmdcbiAgdHlwZTogJ2NhbGVuZGFyX2V2ZW50JyB8ICdhY2FkZW1pY19zZWFyY2gnIHwgJ3JlbWluZGVyJ1xuICBkZXNjcmlwdGlvbjogc3RyaW5nXG4gIGRhdGE6IGFueVxuICBjb21wbGV0ZWQ6IGJvb2xlYW5cbiAgY3JlYXRlZEF0OiBEYXRlXG59PiB7XG4gIGNvbnN0IHNlc3Npb24gPSBnZXRDb252ZXJzYXRpb25TZXNzaW9uKHVzZXJJZCwgc2Vzc2lvbklkKVxuICBpZiAoIXNlc3Npb24pIHJldHVybiBbXVxuICBcbiAgcmV0dXJuIHNlc3Npb24ucGVuZGluZ1Rhc2tzLmZpbHRlcih0YXNrID0+ICF0YXNrLmNvbXBsZXRlZClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldENvbnZlcnNhdGlvbkhpc3RvcnkodXNlcklkOiBzdHJpbmcsIHNlc3Npb25JZDogc3RyaW5nLCBsaW1pdDogbnVtYmVyID0gMTApOiBDb252ZXJzYXRpb25UdXJuW10ge1xuICBjb25zdCBzZXNzaW9uID0gZ2V0Q29udmVyc2F0aW9uU2Vzc2lvbih1c2VySWQsIHNlc3Npb25JZClcbiAgaWYgKCFzZXNzaW9uKSByZXR1cm4gW11cbiAgXG4gIHJldHVybiBzZXNzaW9uLnR1cm5zLnNsaWNlKC1saW1pdClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFVzZXJBY3RpdmVTZXNzaW9ucyh1c2VySWQ6IHN0cmluZyk6IENvbnZlcnNhdGlvblNlc3Npb25bXSB7XG4gIGNvbnN0IG9uZUhvdXJBZ28gPSBuZXcgRGF0ZShEYXRlLm5vdygpIC0gKDYwICogNjAgKiAxMDAwKSlcbiAgcmV0dXJuIHRlbXBDb252ZXJzYXRpb25zLmZpbHRlcihzZXNzaW9uID0+IFxuICAgIHNlc3Npb24udXNlcklkID09PSB1c2VySWQgJiYgc2Vzc2lvbi5sYXN0VXBkYXRlID4gb25lSG91ckFnb1xuICApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjbGVhbnVwT2xkQ29udmVyc2F0aW9ucygpOiB2b2lkIHtcbiAgY29uc3Qgc2l4SG91cnNBZ28gPSBuZXcgRGF0ZShEYXRlLm5vdygpIC0gKDYgKiA2MCAqIDYwICogMTAwMCkpXG4gIGNvbnN0IGJlZm9yZSA9IHRlbXBDb252ZXJzYXRpb25zLmxlbmd0aFxuICBcbiAgLy8gUmVtb3ZlIGNvbnZlcnNhdGlvbnMgb2xkZXIgdGhhbiA2IGhvdXJzXG4gIGZvciAobGV0IGkgPSB0ZW1wQ29udmVyc2F0aW9ucy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGlmICh0ZW1wQ29udmVyc2F0aW9uc1tpXS5sYXN0VXBkYXRlIDwgc2l4SG91cnNBZ28pIHtcbiAgICAgIHRlbXBDb252ZXJzYXRpb25zLnNwbGljZShpLCAxKVxuICAgIH1cbiAgfVxuICBcbiAgY29uc3QgYWZ0ZXIgPSB0ZW1wQ29udmVyc2F0aW9ucy5sZW5ndGhcbiAgaWYgKGJlZm9yZSAhPT0gYWZ0ZXIpIHtcbiAgICBjb25zb2xlLmxvZyhg8J+nuSBDbGVhbmVkIHVwICR7YmVmb3JlIC0gYWZ0ZXJ9IG9sZCBjb252ZXJzYXRpb24gc2Vzc2lvbnNgKVxuICB9XG59XG5cbi8vIEluaXRpYWxpemUgZGVmYXVsdCB1c2VycyBhdXRvbWF0aWNhbGx5XG5pbXBvcnQgYmNyeXB0IGZyb20gXCJiY3J5cHRqc1wiXG5cbmZ1bmN0aW9uIGluaXREZWZhdWx0VXNlcnMoKSB7XG4gIC8vIENoZWNrIGlmIGRlbW8gdXNlcnMgYWxyZWFkeSBleGlzdCB0byBhdm9pZCBkdXBsaWNhdGVzXG4gIGNvbnN0IHN0dWRlbnRFeGlzdHMgPSBmaW5kVXNlckJ5RW1haWwoXCJlc3R1ZGlhbnRlQGRlbW8uY29tXCIpXG4gIGNvbnN0IGluc3RydWN0b3JFeGlzdHMgPSBmaW5kVXNlckJ5RW1haWwoXCJpbnN0cnVjdG9yQGRlbW8uY29tXCIpXG4gIFxuICBpZiAoIXN0dWRlbnRFeGlzdHMgfHwgIWluc3RydWN0b3JFeGlzdHMpIHtcbiAgICBjb25zb2xlLmxvZyhcIvCflKcgSW5pY2lhbGl6YW5kbyB1c3VhcmlvcyBwb3IgZGVmZWN0by4uLlwiKVxuICAgIFxuICAgIHRyeSB7XG4gICAgICBjb25zdCBoYXNoZWRQYXNzd29yZCA9IGJjcnlwdC5oYXNoU3luYyhcIkVzdHVkaWFudGUxMjMhISFcIiwgMTIpXG4gICAgICBcbiAgICAgIC8vIE9ubHkgYWRkIHN0dWRlbnQgaWYgZG9lc24ndCBleGlzdFxuICAgICAgaWYgKCFzdHVkZW50RXhpc3RzKSB7XG4gICAgICAgIGFkZFVzZXIoe1xuICAgICAgICAgIGlkOiBcImRlbW8tc3R1ZGVudC1maXhlZFwiLFxuICAgICAgICAgIG5hbWU6IFwiRXN0dWRpYW50ZSBEZW1vXCIsXG4gICAgICAgICAgZW1haWw6IFwiZXN0dWRpYW50ZUBkZW1vLmNvbVwiLFxuICAgICAgICAgIHBhc3N3b3JkOiBoYXNoZWRQYXNzd29yZCxcbiAgICAgICAgICByb2xlOiBcIlNUVURFTlRcIixcbiAgICAgICAgICBzdHVkZW50SWQ6IFwiRVNULTIwMjUtMDAxXCIsXG4gICAgICAgICAgc3RhdHVzOiBcIkFDVElWRVwiLFxuICAgICAgICAgIGVucm9sbG1lbnRZZWFyOiAyMDI1LFxuICAgICAgICAgIGFjYWRlbWljWWVhcjogXCIyMDI1LTIwMjZcIixcbiAgICAgICAgICBwcm9ncmFtOiBcIkluZ2VuaWVyw61hIGVuIFNpc3RlbWFzXCIsXG4gICAgICAgICAgcGhvbmVOdW1iZXI6IFwiKzEyMzQ1Njc4OTBcIixcbiAgICAgICAgICBkYXRlT2ZCaXJ0aDogbmV3IERhdGUoXCIyMDAwLTAxLTAxXCIpLFxuICAgICAgICAgIGFkZHJlc3M6IFwiRGVtbyBBZGRyZXNzIDEyM1wiLFxuICAgICAgICAgIGVtZXJnZW5jeUNvbnRhY3Q6IHtcbiAgICAgICAgICAgIG5hbWU6IFwiQ29udGFjdG8gRGVtb1wiLFxuICAgICAgICAgICAgcGhvbmU6IFwiKzA5ODc2NTQzMjFcIixcbiAgICAgICAgICAgIHJlbGF0aW9uc2hpcDogXCJQYWRyZVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCksXG4gICAgICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpLFxuICAgICAgICB9KVxuICAgICAgICBjb25zb2xlLmxvZyhcIuKchSBVc3VhcmlvIGVzdHVkaWFudGUgZGVtbyBjcmVhZG9cIilcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gT25seSBhZGQgaW5zdHJ1Y3RvciBpZiBkb2Vzbid0IGV4aXN0XG4gICAgICBpZiAoIWluc3RydWN0b3JFeGlzdHMpIHtcbiAgICAgICAgYWRkVXNlcih7XG4gICAgICAgICAgaWQ6IFwiZGVtby1pbnN0cnVjdG9yLWZpeGVkXCIsXG4gICAgICAgICAgbmFtZTogXCJJbnN0cnVjdG9yIERlbW9cIixcbiAgICAgICAgICBlbWFpbDogXCJpbnN0cnVjdG9yQGRlbW8uY29tXCIsXG4gICAgICAgICAgcGFzc3dvcmQ6IGhhc2hlZFBhc3N3b3JkLFxuICAgICAgICAgIHJvbGU6IFwiSU5TVFJVQ1RPUlwiLFxuICAgICAgICAgIHN0dWRlbnRJZDogbnVsbCxcbiAgICAgICAgICBzdGF0dXM6IFwiQUNUSVZFXCIsXG4gICAgICAgICAgZW5yb2xsbWVudFllYXI6IDIwMjUsXG4gICAgICAgICAgYWNhZGVtaWNZZWFyOiBcIjIwMjUtMjAyNlwiLFxuICAgICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKSxcbiAgICAgICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKCksXG4gICAgICAgIH0pXG4gICAgICAgIGNvbnNvbGUubG9nKFwi4pyFIFVzdWFyaW8gaW5zdHJ1Y3RvciBkZW1vIGNyZWFkb1wiKVxuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zb2xlLmxvZyhcIuKchSBWZXJpZmljYWNpw7NuIGRlIHVzdWFyaW9zIHBvciBkZWZlY3RvIGNvbXBsZXRhZGFcIilcbiAgICAgIFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwi4p2MIEVycm9yIGNyZWFuZG8gdXN1YXJpb3MgcG9yIGRlZmVjdG86XCIsIGVycm9yKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zb2xlLmxvZyhcIuKchSBVc3VhcmlvcyBkZW1vIHlhIGV4aXN0ZW4sIG5vIHNlIHJlaW5pY2lhbGl6YW5cIilcbiAgfVxuICBcbiAgLy8gQWx3YXlzIGNoZWNrIGFuZCBpbml0aWFsaXplIHNhbXBsZSByZXBvcnRzXG4gIGluaXRTYW1wbGVSZXBvcnRzKClcbn1cblxuZnVuY3Rpb24gaW5pdFNhbXBsZVJlcG9ydHMoKSB7XG4gIC8vIENoZWNrIGlmIHNhbXBsZSByZXBvcnRzIGFscmVhZHkgZXhpc3QgZm9yIGRlbW8gc3R1ZGVudFxuICBjb25zdCBleGlzdGluZ1NhbXBsZVJlcG9ydHMgPSB0ZW1wV2Vla2x5UmVwb3J0cy5maWx0ZXIocmVwb3J0ID0+IHJlcG9ydC51c2VySWQgPT09IFwiZGVtby1zdHVkZW50LWZpeGVkXCIpXG4gIFxuICBpZiAoZXhpc3RpbmdTYW1wbGVSZXBvcnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGNvbnNvbGUubG9nKFwi8J+TnSBJbmljaWFsaXphbmRvIHJlcG9ydGVzIGRlIG11ZXN0cmEuLi5cIilcbiAgICBcbiAgICB0cnkge1xuICAgICAgLy8gR2V0IGN1cnJlbnQgd2VlayBkYXRlc1xuICAgICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKVxuICAgICAgY29uc3QgY3VycmVudFdlZWsgPSBnZXRDdXJyZW50V2Vla1N0YXJ0KClcbiAgICAgIGNvbnN0IGN1cnJlbnRXZWVrRW5kID0gZ2V0Q3VycmVudFdlZWtFbmQoKVxuICAgICAgXG4gICAgICAvLyBQcmV2aW91cyB3ZWVrXG4gICAgICBjb25zdCBwcmV2V2VlayA9IG5ldyBEYXRlKGN1cnJlbnRXZWVrKVxuICAgICAgcHJldldlZWsuc2V0RGF0ZShwcmV2V2Vlay5nZXREYXRlKCkgLSA3KVxuICAgICAgY29uc3QgcHJldldlZWtFbmQgPSBuZXcgRGF0ZShjdXJyZW50V2Vla0VuZClcbiAgICAgIHByZXZXZWVrRW5kLnNldERhdGUocHJldldlZWtFbmQuZ2V0RGF0ZSgpIC0gNylcbiAgICAgIFxuICAgICAgLy8gU2FtcGxlIHJlcG9ydCBmcm9tIHByZXZpb3VzIHdlZWtcbiAgICAgIGFkZFdlZWtseVJlcG9ydCh7XG4gICAgICAgIGlkOiBcInNhbXBsZS1yZXBvcnQtMVwiLFxuICAgICAgICB1c2VySWQ6IFwiZGVtby1zdHVkZW50LWZpeGVkXCIsXG4gICAgICAgIHdlZWtTdGFydDogcHJldldlZWssXG4gICAgICAgIHdlZWtFbmQ6IHByZXZXZWVrRW5kLFxuICAgICAgICBzdWJtaXR0ZWRBdDogbmV3IERhdGUocHJldldlZWtFbmQuZ2V0VGltZSgpIC0gMjQgKiA2MCAqIDYwICogMTAwMCksIC8vIDEgZGF5IGJlZm9yZSB3ZWVrIGVuZFxuICAgICAgICByZXNwb25zZXM6IHtcbiAgICAgICAgICB0ZW1hc1lEb21pbmlvOiBcIkVzdGEgc2VtYW5hIHRyYWJhamFtb3MgY29uIEphdmFTY3JpcHQgYsOhc2ljbyAtIE5pdmVsIDM6IERvbWlubyBmdW5jaW9uZXMgeSBhcnJheXMsIHkgZXN0b3kgYXByZW5kaWVuZG8gb2JqZXRvcyBjb21wbGVqb3MuXCIsXG4gICAgICAgICAgZXZpZGVuY2lhQXByZW5kaXphamU6IFwiQ29tcGxldMOpIHVuIHByb3llY3RvIGRlIFRvLURvIExpc3QgdXNhbmRvIEphdmFTY3JpcHQgdmFuaWxsYS4gSW1wbGVtZW50w6kgZnVuY2lvbmVzIHBhcmEgYWdyZWdhciwgZWRpdGFyIHkgZWxpbWluYXIgdGFyZWFzIHVzYW5kbyBhcnJheXMgeSBvYmpldG9zLlwiLFxuICAgICAgICAgIGRpZmljdWx0YWRlc0VzdHJhdGVnaWFzOiBcIlR1dmUgZGlmaWN1bHRhZGVzIGNvbiBlbCBtYW5lam8gZGUgZXZlbnRvcyBlbiBKYXZhU2NyaXB0LiBMbyByZXNvbHbDrSBwcmFjdGljYW5kbyBjb24gZWplbXBsb3MgeSBjb25zdWx0YW5kbyBkb2N1bWVudGFjacOzbiBkZSBNRE4uXCIsXG4gICAgICAgICAgY29uZXhpb25lc0FwbGljYWNpb246IFwiTG9zIGNvbmNlcHRvcyBkZSBldmVudG9zIHNlIGNvbmVjdGFuIGNvbiBsYSBpbnRlcmFjdGl2aWRhZCBlbiBhcGxpY2FjaW9uZXMgd2ViLiBQdWVkbyBhcGxpY2FybG8gcGFyYSBjcmVhciBpbnRlcmZhY2VzIG3DoXMgZGluw6FtaWNhcy5cIixcbiAgICAgICAgICBjb21lbnRhcmlvc0FkaWNpb25hbGVzOiBcIk1lIHNpZW50byBtw6FzIGNvbmZpYWRvIGNvbiBKYXZhU2NyaXB0LiBRdWllcm8gc2VndWlyIHByYWN0aWNhbmRvIGNvbiBwcm95ZWN0b3MgbcOhcyBjb21wbGVqb3MuXCJcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIFxuICAgICAgLy8gVHdvIHdlZWtzIGFnbyByZXBvcnQgIFxuICAgICAgY29uc3QgdHdvV2Vla3NBZ28gPSBuZXcgRGF0ZShjdXJyZW50V2VlaylcbiAgICAgIHR3b1dlZWtzQWdvLnNldERhdGUodHdvV2Vla3NBZ28uZ2V0RGF0ZSgpIC0gMTQpXG4gICAgICBjb25zdCB0d29XZWVrc0Fnb0VuZCA9IG5ldyBEYXRlKGN1cnJlbnRXZWVrRW5kKVxuICAgICAgdHdvV2Vla3NBZ29FbmQuc2V0RGF0ZSh0d29XZWVrc0Fnb0VuZC5nZXREYXRlKCkgLSAxNClcbiAgICAgIFxuICAgICAgYWRkV2Vla2x5UmVwb3J0KHtcbiAgICAgICAgaWQ6IFwic2FtcGxlLXJlcG9ydC0yXCIsXG4gICAgICAgIHVzZXJJZDogXCJkZW1vLXN0dWRlbnQtZml4ZWRcIiwgXG4gICAgICAgIHdlZWtTdGFydDogdHdvV2Vla3NBZ28sXG4gICAgICAgIHdlZWtFbmQ6IHR3b1dlZWtzQWdvRW5kLFxuICAgICAgICBzdWJtaXR0ZWRBdDogbmV3IERhdGUodHdvV2Vla3NBZ29FbmQuZ2V0VGltZSgpIC0gMTIgKiA2MCAqIDYwICogMTAwMCksIC8vIDEyIGhvdXJzIGJlZm9yZSB3ZWVrIGVuZFxuICAgICAgICByZXNwb25zZXM6IHtcbiAgICAgICAgICB0ZW1hc1lEb21pbmlvOiBcIkVzdGEgc2VtYW5hIGVzdHVkaWFtb3MgQ1NTIEdyaWQgeSBGbGV4Ym94IC0gTml2ZWwgMjogRW50aWVuZG8gbG9zIGNvbmNlcHRvcyBiw6FzaWNvcyBwZXJvIGHDum4gdGVuZ28gZHVkYXMgY29uIGxheW91dHMgY29tcGxlam9zLlwiLFxuICAgICAgICAgIGV2aWRlbmNpYUFwcmVuZGl6YWplOiBcIlJlY3Jlw6kgZWwgbGF5b3V0IGRlIHVuYSBww6FnaW5hIHdlYiB1c2FuZG8gQ1NTIEdyaWQuIExvZ3LDqSBoYWNlciB1bmEgZXN0cnVjdHVyYSByZXNwb25zaXZlIGNvbiBoZWFkZXIsIHNpZGViYXIgeSBtYWluIGNvbnRlbnQuXCIsXG4gICAgICAgICAgZGlmaWN1bHRhZGVzRXN0cmF0ZWdpYXM6IFwiTWUgY29uZnVuZMOtIGNvbiBsYXMgcHJvcGllZGFkZXMgZ3JpZC10ZW1wbGF0ZS1hcmVhcy4gUmVzb2x2w60gZWwgcHJvYmxlbWEgZGlidWphbmRvIGVsIGxheW91dCBlbiBwYXBlbCBwcmltZXJvLlwiLFxuICAgICAgICAgIGNvbmV4aW9uZXNBcGxpY2FjaW9uOiBcIkNTUyBHcmlkIGVzIHBlcmZlY3RvIHBhcmEgY3JlYXIgbGF5b3V0cyBkZSBww6FnaW5hcyB3ZWIgbW9kZXJuYXMuIExvIHVzYXLDqSBlbiBtaSBwcm95ZWN0byBmaW5hbCBkZSBww6FnaW5hIHBvcnRmb2xpby5cIixcbiAgICAgICAgICBjb21lbnRhcmlvc0FkaWNpb25hbGVzOiBcIkNTUyBlcyBtw6FzIGRpdmVydGlkbyBkZSBsbyBxdWUgcGVuc2FiYS4gTWUgZ3VzdGEgdmVyIGxvcyByZXN1bHRhZG9zIHZpc3VhbGVzIGlubWVkaWF0b3MuXCJcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coXCLinIUgUmVwb3J0ZXMgZGUgbXVlc3RyYSBjcmVhZG9zIGV4aXRvc2FtZW50ZVwiKVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwi4p2MIEVycm9yIGNyZWFuZG8gcmVwb3J0ZXMgZGUgbXVlc3RyYTpcIiwgZXJyb3IpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnNvbGUubG9nKFwi4pyFIFJlcG9ydGVzIGRlIG11ZXN0cmEgeWEgZXhpc3Rlbiwgbm8gc2UgcmVpbmljaWFsaXphblwiKVxuICB9XG59XG5cbi8vIEluaXRpYWxpemUgb24gbW9kdWxlIGxvYWRcbmluaXREZWZhdWx0VXNlcnMoKSJdLCJuYW1lcyI6WyJnbG9iYWxGb3JTdG9yYWdlIiwiZ2xvYmFsVGhpcyIsInRlbXBVc2VycyIsInRlbXBXZWVrbHlSZXBvcnRzIiwiYWRkVXNlciIsInVzZXIiLCJwdXNoIiwiZmluZFVzZXJCeUVtYWlsIiwiZW1haWwiLCJmaW5kIiwiZmluZFVzZXJCeVN0dWRlbnRJZCIsInN0dWRlbnRJZCIsImZpbmRVc2VyQnlJZCIsImlkIiwiZ2V0QWxsVXNlcnMiLCJmaW5kVXNlcnNCeVJvbGUiLCJyb2xlIiwiZmlsdGVyIiwiZmluZFVzZXJzQnlQcm9ncmFtIiwicHJvZ3JhbSIsImZpbmRVc2Vyc0J5U3RhdHVzIiwic3RhdHVzIiwidXBkYXRlVXNlciIsInVwZGF0ZXMiLCJ1c2VySW5kZXgiLCJmaW5kSW5kZXgiLCJ1cGRhdGVkQXQiLCJEYXRlIiwiZGVsZXRlVXNlciIsInNwbGljZSIsInZhbGlkYXRlU3R1ZGVudElkIiwic3R1ZGVudElkUmVnZXgiLCJ0ZXN0IiwiZ2VuZXJhdGVTdHVkZW50SWQiLCJjdXJyZW50WWVhciIsImdldEZ1bGxZZWFyIiwiZXhpc3RpbmdJZHMiLCJzdGFydHNXaXRoIiwibWFwIiwic29ydCIsIm5leHROdW1iZXIiLCJsZW5ndGgiLCJsYXN0SWQiLCJsYXN0TnVtYmVyIiwicGFyc2VJbnQiLCJzcGxpdCIsInRvU3RyaW5nIiwicGFkU3RhcnQiLCJhZGRXZWVrbHlSZXBvcnQiLCJyZXBvcnQiLCJmaW5kV2Vla2x5UmVwb3J0c0J5VXNlciIsInVzZXJJZCIsImZpbmRXZWVrbHlSZXBvcnRCeVVzZXJBbmRXZWVrIiwid2Vla1N0YXJ0IiwiZ2V0VGltZSIsImdldEFsbFdlZWtseVJlcG9ydHMiLCJnZXRXZWVrbHlSZXBvcnRzQnlEYXRlUmFuZ2UiLCJzdGFydERhdGUiLCJlbmREYXRlIiwid2Vla0VuZCIsImdldEN1cnJlbnRXZWVrU3RhcnQiLCJub3ciLCJtb25kYXkiLCJkYXkiLCJnZXREYXkiLCJkaWZmIiwiZ2V0RGF0ZSIsInNldERhdGUiLCJzZXRIb3VycyIsImdldEN1cnJlbnRXZWVrRW5kIiwiY2FuU3VibWl0VGhpc1dlZWsiLCJjdXJyZW50RGF0ZSIsImV4aXN0aW5nUmVwb3J0IiwiaXNDdXJyZW50V2VlayIsImNvbnNvbGUiLCJsb2ciLCJ0b0lTT1N0cmluZyIsImdldFdlZWtEYXRlcyIsImRhdGUiLCJzdGFydCIsImVuZCIsImdldE1vbnRoV2Vla3MiLCJ5ZWFyIiwibW9udGgiLCJ3ZWVrcyIsImZpcnN0RGF5IiwibGFzdERheSIsImN1cnJlbnQiLCJkYXlPZldlZWsiLCJkYXlzVG9TdWJ0cmFjdCIsImdldEV2ZW50cyIsImdldFVzZXJDYWxlbmRhckRhdGEiLCJyZXF1aXJlIiwidXNlckRhdGEiLCJldmVudHMiLCJlcnJvciIsImdldEFsbENhbGVuZGFyRXZlbnRzIiwiZ2V0VXBjb21pbmdFdmVudHMiLCJkYXlzIiwiYWxsRXZlbnRzIiwiZnV0dXJlRGF0ZSIsImV2ZW50IiwiZXZlbnREYXRlIiwiYSIsImIiLCJnZXRFdmVudHNGb3JEYXRlUmFuZ2UiLCJmaW5kRXZlbnRCeUlkIiwiZXZlbnRJZCIsImdsb2JhbEZvckNvbnZlcnNhdGlvbnMiLCJ0ZW1wQ29udmVyc2F0aW9ucyIsImdldENvbnZlcnNhdGlvblNlc3Npb24iLCJzZXNzaW9uSWQiLCJzZXNzaW9uIiwiY3JlYXRlQ29udmVyc2F0aW9uU2Vzc2lvbiIsImV4aXN0aW5nSW5kZXgiLCJuZXdTZXNzaW9uIiwidHVybnMiLCJjdXJyZW50VG9waWMiLCJ1bmRlZmluZWQiLCJjdXJyZW50U3ViamVjdCIsInBlbmRpbmdUYXNrcyIsImxhc3RVcGRhdGUiLCJ1cGRhdGVDb252ZXJzYXRpb25TZXNzaW9uIiwiaW5kZXgiLCJzIiwiYWRkQ29udmVyc2F0aW9uVHVybiIsImNvbnRlbnQiLCJtZXRhZGF0YSIsInR1cm4iLCJNYXRoIiwicmFuZG9tIiwic3Vic3RyIiwidGltZXN0YW1wIiwic2xpY2UiLCJhZGRQZW5kaW5nVGFzayIsInR5cGUiLCJkZXNjcmlwdGlvbiIsImRhdGEiLCJ0YXNrIiwiY29tcGxldGVkIiwiY3JlYXRlZEF0IiwibWFya1Rhc2tDb21wbGV0ZWQiLCJ0YXNrSWQiLCJyZXN1bHQiLCJ0IiwiZ2V0UGVuZGluZ1Rhc2tzIiwiZ2V0Q29udmVyc2F0aW9uSGlzdG9yeSIsImxpbWl0IiwiZ2V0VXNlckFjdGl2ZVNlc3Npb25zIiwib25lSG91ckFnbyIsImNsZWFudXBPbGRDb252ZXJzYXRpb25zIiwic2l4SG91cnNBZ28iLCJiZWZvcmUiLCJpIiwiYWZ0ZXIiLCJiY3J5cHQiLCJpbml0RGVmYXVsdFVzZXJzIiwic3R1ZGVudEV4aXN0cyIsImluc3RydWN0b3JFeGlzdHMiLCJoYXNoZWRQYXNzd29yZCIsImhhc2hTeW5jIiwibmFtZSIsInBhc3N3b3JkIiwiZW5yb2xsbWVudFllYXIiLCJhY2FkZW1pY1llYXIiLCJwaG9uZU51bWJlciIsImRhdGVPZkJpcnRoIiwiYWRkcmVzcyIsImVtZXJnZW5jeUNvbnRhY3QiLCJwaG9uZSIsInJlbGF0aW9uc2hpcCIsImluaXRTYW1wbGVSZXBvcnRzIiwiZXhpc3RpbmdTYW1wbGVSZXBvcnRzIiwiY3VycmVudFdlZWsiLCJjdXJyZW50V2Vla0VuZCIsInByZXZXZWVrIiwicHJldldlZWtFbmQiLCJzdWJtaXR0ZWRBdCIsInJlc3BvbnNlcyIsInRlbWFzWURvbWluaW8iLCJldmlkZW5jaWFBcHJlbmRpemFqZSIsImRpZmljdWx0YWRlc0VzdHJhdGVnaWFzIiwiY29uZXhpb25lc0FwbGljYWNpb24iLCJjb21lbnRhcmlvc0FkaWNpb25hbGVzIiwidHdvV2Vla3NBZ28iLCJ0d29XZWVrc0Fnb0VuZCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/temp-storage.ts\n"));

/***/ })

});