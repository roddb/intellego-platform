"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/dashboard/student/page",{

/***/ "(app-pages-browser)/./src/lib/temp-storage.ts":
/*!*********************************!*\
  !*** ./src/lib/temp-storage.ts ***!
  \*********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addConversationTurn: () => (/* binding */ addConversationTurn),\n/* harmony export */   addPendingTask: () => (/* binding */ addPendingTask),\n/* harmony export */   addUser: () => (/* binding */ addUser),\n/* harmony export */   addWeeklyReport: () => (/* binding */ addWeeklyReport),\n/* harmony export */   canSubmitThisWeek: () => (/* binding */ canSubmitThisWeek),\n/* harmony export */   cleanupOldConversations: () => (/* binding */ cleanupOldConversations),\n/* harmony export */   createConversationSession: () => (/* binding */ createConversationSession),\n/* harmony export */   deleteUser: () => (/* binding */ deleteUser),\n/* harmony export */   findEventById: () => (/* binding */ findEventById),\n/* harmony export */   findUserByEmail: () => (/* binding */ findUserByEmail),\n/* harmony export */   findUserById: () => (/* binding */ findUserById),\n/* harmony export */   findUserByStudentId: () => (/* binding */ findUserByStudentId),\n/* harmony export */   findUsersByProgram: () => (/* binding */ findUsersByProgram),\n/* harmony export */   findUsersByRole: () => (/* binding */ findUsersByRole),\n/* harmony export */   findUsersByStatus: () => (/* binding */ findUsersByStatus),\n/* harmony export */   findWeeklyReportByUserAndWeek: () => (/* binding */ findWeeklyReportByUserAndWeek),\n/* harmony export */   findWeeklyReportsByUser: () => (/* binding */ findWeeklyReportsByUser),\n/* harmony export */   generateStudentId: () => (/* binding */ generateStudentId),\n/* harmony export */   getAllCalendarEvents: () => (/* binding */ getAllCalendarEvents),\n/* harmony export */   getAllUsers: () => (/* binding */ getAllUsers),\n/* harmony export */   getAllWeeklyReports: () => (/* binding */ getAllWeeklyReports),\n/* harmony export */   getConversationHistory: () => (/* binding */ getConversationHistory),\n/* harmony export */   getConversationSession: () => (/* binding */ getConversationSession),\n/* harmony export */   getCurrentWeekEnd: () => (/* binding */ getCurrentWeekEnd),\n/* harmony export */   getCurrentWeekStart: () => (/* binding */ getCurrentWeekStart),\n/* harmony export */   getEvents: () => (/* binding */ getEvents),\n/* harmony export */   getEventsForDateRange: () => (/* binding */ getEventsForDateRange),\n/* harmony export */   getMonthWeeks: () => (/* binding */ getMonthWeeks),\n/* harmony export */   getPendingTasks: () => (/* binding */ getPendingTasks),\n/* harmony export */   getUpcomingEvents: () => (/* binding */ getUpcomingEvents),\n/* harmony export */   getUserActiveSessions: () => (/* binding */ getUserActiveSessions),\n/* harmony export */   getWeekDates: () => (/* binding */ getWeekDates),\n/* harmony export */   getWeeklyReportsByDateRange: () => (/* binding */ getWeeklyReportsByDateRange),\n/* harmony export */   markTaskCompleted: () => (/* binding */ markTaskCompleted),\n/* harmony export */   tempConversations: () => (/* binding */ tempConversations),\n/* harmony export */   tempUsers: () => (/* binding */ tempUsers),\n/* harmony export */   tempWeeklyReports: () => (/* binding */ tempWeeklyReports),\n/* harmony export */   updateConversationSession: () => (/* binding */ updateConversationSession),\n/* harmony export */   updateUser: () => (/* binding */ updateUser),\n/* harmony export */   validateStudentId: () => (/* binding */ validateStudentId)\n/* harmony export */ });\n/* harmony import */ var bcryptjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! bcryptjs */ \"(app-pages-browser)/./node_modules/bcryptjs/index.js\");\n// Temporary user storage - replace with database later\n// Singleton pattern to persist data across requests\nconst globalForStorage = globalThis;\nvar _globalForStorage_tempUsers;\nconst tempUsers = (_globalForStorage_tempUsers = globalForStorage.tempUsers) !== null && _globalForStorage_tempUsers !== void 0 ? _globalForStorage_tempUsers : [];\nvar _globalForStorage_tempWeeklyReports;\nconst tempWeeklyReports = (_globalForStorage_tempWeeklyReports = globalForStorage.tempWeeklyReports) !== null && _globalForStorage_tempWeeklyReports !== void 0 ? _globalForStorage_tempWeeklyReports : [];\n// Assign to globalThis to persist across requests\nglobalForStorage.tempUsers = tempUsers;\nglobalForStorage.tempWeeklyReports = tempWeeklyReports;\nfunction addUser(user) {\n    tempUsers.push(user);\n}\nfunction findUserByEmail(email) {\n    return tempUsers.find((user)=>user.email === email);\n}\nfunction findUserByStudentId(studentId) {\n    return tempUsers.find((user)=>user.studentId === studentId);\n}\nfunction findUserById(id) {\n    return tempUsers.find((user)=>user.id === id);\n}\nfunction getAllUsers() {\n    return tempUsers;\n}\nfunction findUsersByRole(role) {\n    return tempUsers.filter((user)=>user.role === role);\n}\nfunction findUsersByProgram(program) {\n    return tempUsers.filter((user)=>user.program === program);\n}\nfunction findUsersByStatus(status) {\n    return tempUsers.filter((user)=>user.status === status);\n}\nfunction updateUser(id, updates) {\n    const userIndex = tempUsers.findIndex((user)=>user.id === id);\n    if (userIndex !== -1) {\n        tempUsers[userIndex] = {\n            ...tempUsers[userIndex],\n            ...updates,\n            updatedAt: new Date()\n        };\n        return tempUsers[userIndex];\n    }\n    return null;\n}\nfunction deleteUser(id) {\n    const userIndex = tempUsers.findIndex((user)=>user.id === id);\n    if (userIndex !== -1) {\n        return tempUsers.splice(userIndex, 1)[0];\n    }\n    return null;\n}\nfunction validateStudentId(studentId) {\n    // Formato sugerido: EST-YYYY-XXX (ej: EST-2024-001)\n    const studentIdRegex = /^EST-\\d{4}-\\d{3}$/;\n    return studentIdRegex.test(studentId);\n}\nfunction generateStudentId() {\n    const currentYear = new Date().getFullYear();\n    const existingIds = tempUsers.filter((user)=>user.studentId && user.studentId.startsWith(\"EST-\".concat(currentYear))).map((user)=>user.studentId).sort();\n    let nextNumber = 1;\n    if (existingIds.length > 0) {\n        const lastId = existingIds[existingIds.length - 1];\n        const lastNumber = parseInt(lastId.split('-')[2]);\n        nextNumber = lastNumber + 1;\n    }\n    return \"EST-\".concat(currentYear, \"-\").concat(nextNumber.toString().padStart(3, '0'));\n}\n// Weekly Reports Functions\nfunction addWeeklyReport(report) {\n    tempWeeklyReports.push(report);\n}\nfunction findWeeklyReportsByUser(userId) {\n    return tempWeeklyReports.filter((report)=>report.userId === userId);\n}\nfunction findWeeklyReportByUserAndWeek(userId, weekStart) {\n    return tempWeeklyReports.find((report)=>report.userId === userId && report.weekStart.getTime() === weekStart.getTime());\n}\nfunction getAllWeeklyReports() {\n    return tempWeeklyReports;\n}\nfunction getWeeklyReportsByDateRange(startDate, endDate) {\n    return tempWeeklyReports.filter((report)=>report.weekStart >= startDate && report.weekEnd <= endDate);\n}\n// Date utility functions\nfunction getCurrentWeekStart() {\n    const now = new Date();\n    const monday = new Date(now);\n    const day = now.getDay();\n    const diff = now.getDate() - day + (day === 0 ? -6 : 1 // Adjust for Sunday\n    );\n    monday.setDate(diff);\n    monday.setHours(0, 0, 0, 0);\n    return monday;\n}\nfunction getCurrentWeekEnd() {\n    const weekStart = getCurrentWeekStart();\n    const weekEnd = new Date(weekStart);\n    weekEnd.setDate(weekStart.getDate() + 6);\n    weekEnd.setHours(23, 59, 59, 999);\n    return weekEnd;\n}\nfunction canSubmitThisWeek(userId) {\n    const weekStart = getCurrentWeekStart();\n    const weekEnd = getCurrentWeekEnd();\n    const currentDate = new Date();\n    const existingReport = findWeeklyReportByUserAndWeek(userId, weekStart);\n    // Can submit if:\n    // 1. We are currently in this week (currentDate is between weekStart and weekEnd)\n    // 2. No report exists for this week\n    const isCurrentWeek = currentDate >= weekStart && currentDate <= weekEnd;\n    console.log(\"\\uD83D\\uDD0D Debug canSubmitThisWeek for user \".concat(userId, \":\"));\n    console.log(\"  Current date: \".concat(currentDate.toISOString()));\n    console.log(\"  Week start: \".concat(weekStart.toISOString()));\n    console.log(\"  Week end: \".concat(weekEnd.toISOString()));\n    console.log(\"  Is current week: \".concat(isCurrentWeek));\n    console.log(\"  Existing report: \".concat(existingReport ? 'YES' : 'NO'));\n    console.log(\"  Can submit: \".concat(isCurrentWeek && !existingReport));\n    return isCurrentWeek && !existingReport;\n}\nfunction getWeekDates(date) {\n    const start = new Date(date);\n    const day = start.getDay();\n    const diff = start.getDate() - day + (day === 0 ? -6 : 1);\n    start.setDate(diff);\n    start.setHours(0, 0, 0, 0);\n    const end = new Date(start);\n    end.setDate(start.getDate() + 6);\n    end.setHours(23, 59, 59, 999);\n    return {\n        start,\n        end\n    };\n}\nfunction getMonthWeeks(year, month) {\n    const weeks = [];\n    const firstDay = new Date(year, month, 1);\n    const lastDay = new Date(year, month + 1, 0);\n    let current = new Date(firstDay);\n    // Adjust to start from Monday of first week\n    const dayOfWeek = current.getDay();\n    const daysToSubtract = dayOfWeek === 0 ? 6 : dayOfWeek - 1;\n    current.setDate(current.getDate() - daysToSubtract);\n    while(current <= lastDay){\n        const weekStart = new Date(current);\n        const weekEnd = new Date(current);\n        weekEnd.setDate(weekStart.getDate() + 6);\n        weeks.push({\n            start: weekStart,\n            end: weekEnd\n        });\n        current.setDate(current.getDate() + 7);\n    }\n    return weeks;\n}\n// ===== CALENDAR FUNCTIONS =====\n// These functions integrate with the calendar system for Sara AI\nfunction getEvents(userId) {\n    // Import calendar data functions\n    try {\n        const { getUserCalendarData } = __webpack_require__(/*! ./calendar-data */ \"(app-pages-browser)/./src/lib/calendar-data.ts\");\n        const userData = getUserCalendarData(userId);\n        return (userData === null || userData === void 0 ? void 0 : userData.events) || [];\n    } catch (error) {\n        console.error('Error getting calendar events:', error);\n        return [];\n    }\n}\nfunction getAllCalendarEvents(userId) {\n    // Alias for getEvents for compatibility\n    return getEvents(userId);\n}\nfunction getUpcomingEvents(userId) {\n    let days = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 30;\n    try {\n        const allEvents = getEvents(userId);\n        const now = new Date();\n        const futureDate = new Date();\n        futureDate.setDate(futureDate.getDate() + days);\n        return allEvents.filter((event)=>{\n            const eventDate = new Date(event.date);\n            return eventDate >= now && eventDate <= futureDate;\n        }).sort((a, b)=>new Date(a.date).getTime() - new Date(b.date).getTime());\n    } catch (error) {\n        console.error('Error getting upcoming events:', error);\n        return [];\n    }\n}\nfunction getEventsForDateRange(userId, startDate, endDate) {\n    try {\n        const allEvents = getEvents(userId);\n        return allEvents.filter((event)=>{\n            const eventDate = new Date(event.date);\n            return eventDate >= startDate && eventDate <= endDate;\n        });\n    } catch (error) {\n        console.error('Error getting events for date range:', error);\n        return [];\n    }\n}\nfunction findEventById(userId, eventId) {\n    try {\n        const allEvents = getEvents(userId);\n        return allEvents.find((event)=>event.id === eventId) || null;\n    } catch (error) {\n        console.error('Error finding event by ID:', error);\n        return null;\n    }\n}\n// Global storage for conversations\nconst globalForConversations = globalThis;\nvar _globalForConversations_tempConversations;\nconst tempConversations = (_globalForConversations_tempConversations = globalForConversations.tempConversations) !== null && _globalForConversations_tempConversations !== void 0 ? _globalForConversations_tempConversations : [];\nglobalForConversations.tempConversations = tempConversations;\nfunction getConversationSession(userId, sessionId) {\n    return tempConversations.find((session)=>session.userId === userId && session.sessionId === sessionId) || null;\n}\nfunction createConversationSession(userId, sessionId) {\n    // First remove any old session for the same user/sessionId\n    const existingIndex = tempConversations.findIndex((session)=>session.userId === userId && session.sessionId === sessionId);\n    if (existingIndex !== -1) {\n        tempConversations.splice(existingIndex, 1);\n    }\n    const newSession = {\n        userId,\n        sessionId,\n        turns: [],\n        currentTopic: undefined,\n        currentSubject: undefined,\n        pendingTasks: [],\n        lastUpdate: new Date()\n    };\n    tempConversations.push(newSession);\n    console.log(\"\\uD83D\\uDCAC Created conversation session \".concat(sessionId, \" for user \").concat(userId));\n    return newSession;\n}\nfunction updateConversationSession(session) {\n    const index = tempConversations.findIndex((s)=>s.userId === session.userId && s.sessionId === session.sessionId);\n    if (index !== -1) {\n        tempConversations[index] = {\n            ...session,\n            lastUpdate: new Date()\n        };\n        console.log(\"\\uD83D\\uDCAC Updated session \".concat(session.sessionId, \" - \").concat(session.turns.length, \" turns\"));\n    } else {\n        tempConversations.push({\n            ...session,\n            lastUpdate: new Date()\n        });\n        console.log(\"\\uD83D\\uDCAC Created new session \".concat(session.sessionId, \" during update\"));\n    }\n    return session;\n}\nfunction addConversationTurn(userId, sessionId, role, content) {\n    let metadata = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};\n    let session = getConversationSession(userId, sessionId);\n    if (!session) {\n        session = createConversationSession(userId, sessionId);\n    }\n    const turn = {\n        id: \"turn_\".concat(Date.now(), \"_\").concat(Math.random().toString(36).substr(2, 9)),\n        timestamp: new Date(),\n        role,\n        content,\n        metadata\n    };\n    session.turns.push(turn);\n    // Keep only last 20 turns per session\n    if (session.turns.length > 20) {\n        session.turns = session.turns.slice(-20);\n    }\n    return updateConversationSession(session);\n}\nfunction addPendingTask(userId, sessionId, type, description, data) {\n    let session = getConversationSession(userId, sessionId);\n    if (!session) {\n        session = createConversationSession(userId, sessionId);\n    }\n    const task = {\n        id: \"task_\".concat(Date.now()),\n        type,\n        description,\n        data,\n        completed: false,\n        createdAt: new Date()\n    };\n    session.pendingTasks.push(task);\n    console.log(\"\\uD83D\\uDCCB Added pending task: \".concat(description));\n    updateConversationSession(session);\n}\nfunction markTaskCompleted(userId, sessionId, taskId, result) {\n    const session = getConversationSession(userId, sessionId);\n    if (!session) return false;\n    const task = session.pendingTasks.find((t)=>t.id === taskId);\n    if (!task) return false;\n    task.completed = true;\n    if (result) {\n        task.data.result = result;\n    }\n    console.log(\"✅ Completed task: \".concat(task.description));\n    updateConversationSession(session);\n    return true;\n}\nfunction getPendingTasks(userId, sessionId) {\n    const session = getConversationSession(userId, sessionId);\n    if (!session) return [];\n    return session.pendingTasks.filter((task)=>!task.completed);\n}\nfunction getConversationHistory(userId, sessionId) {\n    let limit = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 10;\n    const session = getConversationSession(userId, sessionId);\n    if (!session) return [];\n    return session.turns.slice(-limit);\n}\nfunction getUserActiveSessions(userId) {\n    const oneHourAgo = new Date(Date.now() - 60 * 60 * 1000);\n    return tempConversations.filter((session)=>session.userId === userId && session.lastUpdate > oneHourAgo);\n}\nfunction cleanupOldConversations() {\n    const sixHoursAgo = new Date(Date.now() - 6 * 60 * 60 * 1000);\n    const before = tempConversations.length;\n    // Remove conversations older than 6 hours\n    for(let i = tempConversations.length - 1; i >= 0; i--){\n        if (tempConversations[i].lastUpdate < sixHoursAgo) {\n            tempConversations.splice(i, 1);\n        }\n    }\n    const after = tempConversations.length;\n    if (before !== after) {\n        console.log(\"\\uD83E\\uDDF9 Cleaned up \".concat(before - after, \" old conversation sessions\"));\n    }\n}\n// Initialize default users automatically\n\nfunction initDefaultUsers() {\n    // Check if demo users already exist to avoid duplicates\n    const studentExists = findUserByEmail(\"estudiante@demo.com\");\n    const instructorExists = findUserByEmail(\"instructor@demo.com\");\n    if (!studentExists || !instructorExists) {\n        console.log(\"🔧 Inicializando usuarios por defecto...\");\n        try {\n            const hashedPassword = bcryptjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].hashSync(\"Estudiante123!!!\", 12);\n            // Only add student if doesn't exist\n            if (!studentExists) {\n                addUser({\n                    id: \"demo-student-fixed\",\n                    name: \"Estudiante Demo\",\n                    email: \"estudiante@demo.com\",\n                    password: hashedPassword,\n                    role: \"STUDENT\",\n                    studentId: \"EST-2025-001\",\n                    status: \"ACTIVE\",\n                    enrollmentYear: 2025,\n                    academicYear: \"2025-2026\",\n                    program: \"Ingeniería en Sistemas\",\n                    phoneNumber: \"+1234567890\",\n                    dateOfBirth: new Date(\"2000-01-01\"),\n                    address: \"Demo Address 123\",\n                    emergencyContact: {\n                        name: \"Contacto Demo\",\n                        phone: \"+0987654321\",\n                        relationship: \"Padre\"\n                    },\n                    createdAt: new Date(),\n                    updatedAt: new Date()\n                });\n                console.log(\"✅ Usuario estudiante demo creado\");\n            }\n            // Only add instructor if doesn't exist\n            if (!instructorExists) {\n                addUser({\n                    id: \"demo-instructor-fixed\",\n                    name: \"Instructor Demo\",\n                    email: \"instructor@demo.com\",\n                    password: hashedPassword,\n                    role: \"INSTRUCTOR\",\n                    studentId: null,\n                    status: \"ACTIVE\",\n                    enrollmentYear: 2025,\n                    academicYear: \"2025-2026\",\n                    createdAt: new Date(),\n                    updatedAt: new Date()\n                });\n                console.log(\"✅ Usuario instructor demo creado\");\n            }\n            console.log(\"✅ Verificación de usuarios por defecto completada\");\n        } catch (error) {\n            console.error(\"❌ Error creando usuarios por defecto:\", error);\n        }\n    } else {\n        console.log(\"✅ Usuarios demo ya existen, no se reinicializan\");\n    }\n    // Always check and initialize sample reports\n    initSampleReports();\n}\nfunction initSampleReports() {\n    // Check if sample reports already exist for demo student\n    const existingSampleReports = tempWeeklyReports.filter((report)=>report.userId === \"demo-student-fixed\");\n    if (existingSampleReports.length === 0) {\n        console.log(\"📝 Inicializando reportes de muestra...\");\n        try {\n            // Get current week dates\n            const now = new Date();\n            const currentWeek = getCurrentWeekStart();\n            const currentWeekEnd = getCurrentWeekEnd();\n            // Previous week\n            const prevWeek = new Date(currentWeek);\n            prevWeek.setDate(prevWeek.getDate() - 7);\n            const prevWeekEnd = new Date(currentWeekEnd);\n            prevWeekEnd.setDate(prevWeekEnd.getDate() - 7);\n            // Sample report from previous week\n            addWeeklyReport({\n                id: \"sample-report-1\",\n                userId: \"demo-student-fixed\",\n                weekStart: prevWeek,\n                weekEnd: prevWeekEnd,\n                submittedAt: new Date(prevWeekEnd.getTime() - 24 * 60 * 60 * 1000),\n                responses: {\n                    temasYDominio: \"Esta semana trabajamos con JavaScript básico - Nivel 3: Domino funciones y arrays, y estoy aprendiendo objetos complejos.\",\n                    evidenciaAprendizaje: \"Completé un proyecto de To-Do List usando JavaScript vanilla. Implementé funciones para agregar, editar y eliminar tareas usando arrays y objetos.\",\n                    dificultadesEstrategias: \"Tuve dificultades con el manejo de eventos en JavaScript. Lo resolví practicando con ejemplos y consultando documentación de MDN.\",\n                    conexionesAplicacion: \"Los conceptos de eventos se conectan con la interactividad en aplicaciones web. Puedo aplicarlo para crear interfaces más dinámicas.\",\n                    comentariosAdicionales: \"Me siento más confiado con JavaScript. Quiero seguir practicando con proyectos más complejos.\"\n                }\n            });\n            // Two weeks ago report  \n            const twoWeeksAgo = new Date(currentWeek);\n            twoWeeksAgo.setDate(twoWeeksAgo.getDate() - 14);\n            const twoWeeksAgoEnd = new Date(currentWeekEnd);\n            twoWeeksAgoEnd.setDate(twoWeeksAgoEnd.getDate() - 14);\n            addWeeklyReport({\n                id: \"sample-report-2\",\n                userId: \"demo-student-fixed\",\n                weekStart: twoWeeksAgo,\n                weekEnd: twoWeeksAgoEnd,\n                submittedAt: new Date(twoWeeksAgoEnd.getTime() - 12 * 60 * 60 * 1000),\n                responses: {\n                    temasYDominio: \"Esta semana estudiamos CSS Grid y Flexbox - Nivel 2: Entiendo los conceptos básicos pero aún tengo dudas con layouts complejos.\",\n                    evidenciaAprendizaje: \"Recreé el layout de una página web usando CSS Grid. Logré hacer una estructura responsive con header, sidebar y main content.\",\n                    dificultadesEstrategias: \"Me confundí con las propiedades grid-template-areas. Resolví el problema dibujando el layout en papel primero.\",\n                    conexionesAplicacion: \"CSS Grid es perfecto para crear layouts de páginas web modernas. Lo usaré en mi proyecto final de página portfolio.\",\n                    comentariosAdicionales: \"CSS es más divertido de lo que pensaba. Me gusta ver los resultados visuales inmediatos.\"\n                }\n            });\n            console.log(\"✅ Reportes de muestra creados exitosamente\");\n        } catch (error) {\n            console.error(\"❌ Error creando reportes de muestra:\", error);\n        }\n    } else {\n        console.log(\"✅ Reportes de muestra ya existen, no se reinicializan\");\n    }\n}\n// Initialize on module load\ninitDefaultUsers();\n// Start conversation cleanup interval\nsetInterval(cleanupOldConversations, 30 * 60 * 1000) // Every 30 minutes\n;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvdGVtcC1zdG9yYWdlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsdURBQXVEO0FBd0R2RCxvREFBb0Q7QUFDcEQsTUFBTUEsbUJBQW1CQztJQUtZRDtBQUE5QixNQUFNRSxZQUF3QkYsQ0FBQUEsOEJBQUFBLGlCQUFpQkUsU0FBUyxjQUExQkYseUNBQUFBLDhCQUE4QixFQUFFO0lBQ3BCQTtBQUExQyxNQUFNRyxvQkFBb0NILENBQUFBLHNDQUFBQSxpQkFBaUJHLGlCQUFpQixjQUFsQ0gsaURBQUFBLHNDQUFzQyxFQUFFO0FBRXpGLGtEQUFrRDtBQUNsREEsaUJBQWlCRSxTQUFTLEdBQUdBO0FBQzdCRixpQkFBaUJHLGlCQUFpQixHQUFHQTtBQUU5QixTQUFTQyxRQUFRQyxJQUFjO0lBQ3BDSCxVQUFVSSxJQUFJLENBQUNEO0FBQ2pCO0FBRU8sU0FBU0UsZ0JBQWdCQyxLQUFhO0lBQzNDLE9BQU9OLFVBQVVPLElBQUksQ0FBQ0osQ0FBQUEsT0FBUUEsS0FBS0csS0FBSyxLQUFLQTtBQUMvQztBQUVPLFNBQVNFLG9CQUFvQkMsU0FBaUI7SUFDbkQsT0FBT1QsVUFBVU8sSUFBSSxDQUFDSixDQUFBQSxPQUFRQSxLQUFLTSxTQUFTLEtBQUtBO0FBQ25EO0FBRU8sU0FBU0MsYUFBYUMsRUFBVTtJQUNyQyxPQUFPWCxVQUFVTyxJQUFJLENBQUNKLENBQUFBLE9BQVFBLEtBQUtRLEVBQUUsS0FBS0E7QUFDNUM7QUFFTyxTQUFTQztJQUNkLE9BQU9aO0FBQ1Q7QUFFTyxTQUFTYSxnQkFBZ0JDLElBQVk7SUFDMUMsT0FBT2QsVUFBVWUsTUFBTSxDQUFDWixDQUFBQSxPQUFRQSxLQUFLVyxJQUFJLEtBQUtBO0FBQ2hEO0FBRU8sU0FBU0UsbUJBQW1CQyxPQUFlO0lBQ2hELE9BQU9qQixVQUFVZSxNQUFNLENBQUNaLENBQUFBLE9BQVFBLEtBQUtjLE9B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Y0FBYyxJQUFJN0osS0FBS2tKO1lBQzdCVyxZQUFZckgsT0FBTyxDQUFDcUgsWUFBWXRILE9BQU8sS0FBSztZQUM1QyxNQUFNdUgsaUJBQWlCLElBQUk5SixLQUFLbUo7WUFDaENXLGVBQWV0SCxPQUFPLENBQUNzSCxlQUFldkgsT0FBTyxLQUFLO1lBRWxEbEIsZ0JBQWdCO2dCQUNkbkMsSUFBSTtnQkFDSnNDLFFBQVE7Z0JBQ1JFLFdBQVdtSTtnQkFDWDdILFNBQVM4SDtnQkFDVFIsYUFBYSxJQUFJdEosS0FBSzhKLGVBQWVuSSxPQUFPLEtBQUssS0FBSyxLQUFLLEtBQUs7Z0JBQ2hFNEgsV0FBVztvQkFDVEMsZUFBZTtvQkFDZkMsc0JBQXNCO29CQUN0QkMseUJBQXlCO29CQUN6QkMsc0JBQXNCO29CQUN0QkMsd0JBQXdCO2dCQUMxQjtZQUNGO1lBRUE3RyxRQUFRQyxHQUFHLENBQUM7UUFDZCxFQUFFLE9BQU9vQixPQUFPO1lBQ2RyQixRQUFRcUIsS0FBSyxDQUFDLHdDQUF3Q0E7UUFDeEQ7SUFDRixPQUFPO1FBQ0xyQixRQUFRQyxHQUFHLENBQUM7SUFDZDtBQUNGO0FBRUEsNEJBQTRCO0FBQzVCaUY7QUFFQSxzQ0FBc0M7QUFDdEM4QixZQUFZcEMseUJBQXlCLEtBQUssS0FBSyxNQUFNLG1CQUFtQiIsInNvdXJjZXMiOlsiL1VzZXJzL3JvZHJpZ29kaWJlcm5hcmRvMzNnbWFpbC5jb20vRG9jdW1lbnRzL0FwcCBEZXZlbG9wbWVudCBQcm95ZWN0cy9JbnRlbGxlZ28gUGxhdGZvcm0vc3JjL2xpYi90ZW1wLXN0b3JhZ2UudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVGVtcG9yYXJ5IHVzZXIgc3RvcmFnZSAtIHJlcGxhY2Ugd2l0aCBkYXRhYmFzZSBsYXRlclxuaW50ZXJmYWNlIFRlbXBVc2VyIHtcbiAgaWQ6IHN0cmluZ1xuICBuYW1lOiBzdHJpbmdcbiAgZW1haWw6IHN0cmluZ1xuICBwYXNzd29yZDogc3RyaW5nXG4gIHN0dWRlbnRJZD86IHN0cmluZyB8IG51bGxcbiAgcm9sZTogc3RyaW5nXG4gIGNyZWF0ZWRBdDogRGF0ZVxuICB1cGRhdGVkQXQ6IERhdGVcbiAgaW1hZ2U/OiBzdHJpbmdcbiAgLy8gQWNhZGVtaWMgZmllbGRzXG4gIHByb2dyYW0/OiBzdHJpbmcgLy8gQ2FycmVyYS9wcm9ncmFtYSBkZSBlc3R1ZGlvc1xuICBhY2FkZW1pY1llYXI/OiBzdHJpbmcgLy8gQcOxbyBhY2Fkw6ltaWNvIChlajogXCIyMDI0LTIwMjVcIilcbiAgZW5yb2xsbWVudFllYXI/OiBudW1iZXIgLy8gQcOxbyBkZSBpbmdyZXNvXG4gIHN0YXR1cz86IFwiQUNUSVZFXCIgfCBcIklOQUNUSVZFXCIgfCBcIlNVU1BFTkRFRFwiIC8vIEVzdGFkbyBkZWwgZXN0dWRpYW50ZVxuICBwaG9uZU51bWJlcj86IHN0cmluZ1xuICBkYXRlT2ZCaXJ0aD86IERhdGVcbiAgYWRkcmVzcz86IHN0cmluZ1xuICBlbWVyZ2VuY3lDb250YWN0Pzoge1xuICAgIG5hbWU6IHN0cmluZ1xuICAgIHBob25lOiBzdHJpbmdcbiAgICByZWxhdGlvbnNoaXA6IHN0cmluZ1xuICB9XG4gIHByZWZlcmVuY2VzPzoge1xuICAgIGVtYWlsTm90aWZpY2F0aW9uczogYm9vbGVhblxuICAgIHB1c2hOb3RpZmljYXRpb25zOiBib29sZWFuXG4gICAgd2Vla2x5UmVtaW5kZXJzOiBib29sZWFuXG4gICAgcHJvZ3Jlc3NSZXBvcnRzOiBib29sZWFuXG4gIH1cbn1cblxuaW50ZXJmYWNlIEF0dGFjaGVkRmlsZSB7XG4gIGZpbGVuYW1lOiBzdHJpbmdcbiAgb3JpZ2luYWxOYW1lOiBzdHJpbmdcbiAgc2l6ZTogbnVtYmVyXG4gIHR5cGU6IHN0cmluZ1xuICB1cmw6IHN0cmluZ1xufVxuXG5pbnRlcmZhY2UgV2Vla2x5UmVwb3J0IHtcbiAgaWQ6IHN0cmluZ1xuICB1c2VySWQ6IHN0cmluZ1xuICB3ZWVrU3RhcnQ6IERhdGVcbiAgd2Vla0VuZDogRGF0ZVxuICBzdWJtaXR0ZWRBdDogRGF0ZVxuICByZXNwb25zZXM6IHtcbiAgICB0ZW1hc1lEb21pbmlvOiBzdHJpbmcgLy8gUHJlZ3VudGEgMVxuICAgIGV2aWRlbmNpYUFwcmVuZGl6YWplOiBzdHJpbmcgLy8gUHJlZ3VudGEgMlxuICAgIGRpZmljdWx0YWRlc0VzdHJhdGVnaWFzOiBzdHJpbmcgLy8gUHJlZ3VudGEgM1xuICAgIGNvbmV4aW9uZXNBcGxpY2FjaW9uOiBzdHJpbmcgLy8gUHJlZ3VudGEgNFxuICAgIGNvbWVudGFyaW9zQWRpY2lvbmFsZXM/OiBzdHJpbmcgLy8gUHJlZ3VudGEgNSAob3BjaW9uYWwpXG4gIH1cbiAgYXR0YWNobWVudHM/OiBBdHRhY2hlZEZpbGVbXSAvLyBBcmNoaXZvcyBhZGp1bnRvc1xufVxuXG4vLyBTaW5nbGV0b24gcGF0dGVybiB0byBwZXJzaXN0IGRhdGEgYWNyb3NzIHJlcXVlc3RzXG5jb25zdCBnbG9iYWxGb3JTdG9yYWdlID0gZ2xvYmFsVGhpcyBhcyB1bmtub3duIGFzIHtcbiAgdGVtcFVzZXJzOiBUZW1wVXNlcltdIHwgdW5kZWZpbmVkXG4gIHRlbXBXZWVrbHlSZXBvcnRzOiBXZWVrbHlSZXBvcnRbXSB8IHVuZGVmaW5lZFxufVxuXG5leHBvcnQgY29uc3QgdGVtcFVzZXJzOiBUZW1wVXNlcltdID0gZ2xvYmFsRm9yU3RvcmFnZS50ZW1wVXNlcnMgPz8gW11cbmV4cG9ydCBjb25zdCB0ZW1wV2Vla2x5UmVwb3J0czogV2Vla2x5UmVwb3J0W10gPSBnbG9iYWxGb3JTdG9yYWdlLnRlbXBXZWVrbHlSZXBvcnRzID8/IFtdXG5cbi8vIEFzc2lnbiB0byBnbG9iYWxUaGlzIHRvIHBlcnNpc3QgYWNyb3NzIHJlcXVlc3RzXG5nbG9iYWxGb3JTdG9yYWdlLnRlbXBVc2VycyA9IHRlbXBVc2Vyc1xuZ2xvYmFsRm9yU3RvcmFnZS50ZW1wV2Vla2x5UmVwb3J0cyA9IHRlbXBXZWVrbHlSZXBvcnRzXG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRVc2VyKHVzZXI6IFRlbXBVc2VyKSB7XG4gIHRlbXBVc2Vycy5wdXNoKHVzZXIpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmaW5kVXNlckJ5RW1haWwoZW1haWw6IHN0cmluZykge1xuICByZXR1cm4gdGVtcFVzZXJzLmZpbmQodXNlciA9PiB1c2VyLmVtYWlsID09PSBlbWFpbClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRVc2VyQnlTdHVkZW50SWQoc3R1ZGVudElkOiBzdHJpbmcpIHtcbiAgcmV0dXJuIHRlbXBVc2Vycy5maW5kKHVzZXIgPT4gdXNlci5zdHVkZW50SWQgPT09IHN0dWRlbnRJZClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRVc2VyQnlJZChpZDogc3RyaW5nKSB7XG4gIHJldHVybiB0ZW1wVXNlcnMuZmluZCh1c2VyID0+IHVzZXIuaWQgPT09IGlkKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0QWxsVXNlcnMoKSB7XG4gIHJldHVybiB0ZW1wVXNlcnNcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRVc2Vyc0J5Um9sZShyb2xlOiBzdHJpbmcpIHtcbiAgcmV0dXJuIHRlbXBVc2Vycy5maWx0ZXIodXNlciA9PiB1c2VyLnJvbGUgPT09IHJvbGUpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmaW5kVXNlcnNCeVByb2dyYW0ocHJvZ3JhbTogc3RyaW5nKSB7XG4gIHJldHVybiB0ZW1wVXNlcnMuZmlsdGVyKHVzZXIgPT4gdXNlci5wcm9ncmFtID09PSBwcm9ncmFtKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZmluZFVzZXJzQnlTdGF0dXMoc3RhdHVzOiBcIkFDVElWRVwiIHwgXCJJTkFDVElWRVwiIHwgXCJTVVNQRU5ERURcIikge1xuICByZXR1cm4gdGVtcFVzZXJzLmZpbHRlcih1c2VyID0+IHVzZXIuc3RhdHVzID09PSBzdGF0dXMpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVVc2VyKGlkOiBzdHJpbmcsIHVwZGF0ZXM6IFBhcnRpYWw8VGVtcFVzZXI+KSB7XG4gIGNvbnN0IHVzZXJJbmRleCA9IHRlbXBVc2Vycy5maW5kSW5kZXgodXNlciA9PiB1c2VyLmlkID09PSBpZClcbiAgaWYgKHVzZXJJbmRleCAhPT0gLTEpIHtcbiAgICB0ZW1wVXNlcnNbdXNlckluZGV4XSA9IHtcbiAgICAgIC4uLnRlbXBVc2Vyc1t1c2VySW5kZXhdLFxuICAgICAgLi4udXBkYXRlcyxcbiAgICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoKVxuICAgIH1cbiAgICByZXR1cm4gdGVtcFVzZXJzW3VzZXJJbmRleF1cbiAgfVxuICByZXR1cm4gbnVsbFxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVsZXRlVXNlcihpZDogc3RyaW5nKSB7XG4gIGNvbnN0IHVzZXJJbmRleCA9IHRlbXBVc2Vycy5maW5kSW5kZXgodXNlciA9PiB1c2VyLmlkID09PSBpZClcbiAgaWYgKHVzZXJJbmRleCAhPT0gLTEpIHtcbiAgICByZXR1cm4gdGVtcFVzZXJzLnNwbGljZSh1c2VySW5kZXgsIDEpWzBdXG4gIH1cbiAgcmV0dXJuIG51bGxcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlU3R1ZGVudElkKHN0dWRlbnRJZDogc3RyaW5nKTogYm9vbGVhbiB7XG4gIC8vIEZvcm1hdG8gc3VnZXJpZG86IEVTVC1ZWVlZLVhYWCAoZWo6IEVTVC0yMDI0LTAwMSlcbiAgY29uc3Qgc3R1ZGVudElkUmVnZXggPSAvXkVTVC1cXGR7NH0tXFxkezN9JC9cbiAgcmV0dXJuIHN0dWRlbnRJZFJlZ2V4LnRlc3Qoc3R1ZGVudElkKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVTdHVkZW50SWQoKTogc3RyaW5nIHtcbiAgY29uc3QgY3VycmVudFllYXIgPSBuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKClcbiAgY29uc3QgZXhpc3RpbmdJZHMgPSB0ZW1wVXNlcnNcbiAgICAuZmlsdGVyKHVzZXIgPT4gdXNlci5zdHVkZW50SWQgJiYgdXNlci5zdHVkZW50SWQuc3RhcnRzV2l0aChgRVNULSR7Y3VycmVudFllYXJ9YCkpXG4gICAgLm1hcCh1c2VyID0+IHVzZXIuc3R1ZGVudElkISlcbiAgICAuc29ydCgpXG5cbiAgbGV0IG5leHROdW1iZXIgPSAxXG4gIGlmIChleGlzdGluZ0lkcy5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgbGFzdElkID0gZXhpc3RpbmdJZHNbZXhpc3RpbmdJZHMubGVuZ3RoIC0gMV1cbiAgICBjb25zdCBsYXN0TnVtYmVyID0gcGFyc2VJbnQobGFzdElkLnNwbGl0KCctJylbMl0pXG4gICAgbmV4dE51bWJlciA9IGxhc3ROdW1iZXIgKyAxXG4gIH1cblxuICByZXR1cm4gYEVTVC0ke2N1cnJlbnRZZWFyfS0ke25leHROdW1iZXIudG9TdHJpbmcoKS5wYWRTdGFydCgzLCAnMCcpfWBcbn1cblxuLy8gV2Vla2x5IFJlcG9ydHMgRnVuY3Rpb25zXG5leHBvcnQgZnVuY3Rpb24gYWRkV2Vla2x5UmVwb3J0KHJlcG9ydDogV2Vla2x5UmVwb3J0KSB7XG4gIHRlbXBXZWVrbHlSZXBvcnRzLnB1c2gocmVwb3J0KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZmluZFdlZWtseVJlcG9ydHNCeVVzZXIodXNlcklkOiBzdHJpbmcpOiBXZWVrbHlSZXBvcnRbXSB7XG4gIHJldHVybiB0ZW1wV2Vla2x5UmVwb3J0cy5maWx0ZXIocmVwb3J0ID0+IHJlcG9ydC51c2VySWQgPT09IHVzZXJJZClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRXZWVrbHlSZXBvcnRCeVVzZXJBbmRXZWVrKHVzZXJJZDogc3RyaW5nLCB3ZWVrU3RhcnQ6IERhdGUpOiBXZWVrbHlSZXBvcnQgfCB1bmRlZmluZWQge1xuICByZXR1cm4gdGVtcFdlZWtseVJlcG9ydHMuZmluZChyZXBvcnQgPT4gXG4gICAgcmVwb3J0LnVzZXJJZCA9PT0gdXNlcklkICYmIFxuICAgIHJlcG9ydC53ZWVrU3RhcnQuZ2V0VGltZSgpID09PSB3ZWVrU3RhcnQuZ2V0VGltZSgpXG4gIClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEFsbFdlZWtseVJlcG9ydHMoKTogV2Vla2x5UmVwb3J0W10ge1xuICByZXR1cm4gdGVtcFdlZWtseVJlcG9ydHNcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFdlZWtseVJlcG9ydHNCeURhdGVSYW5nZShzdGFydERhdGU6IERhdGUsIGVuZERhdGU6IERhdGUpOiBXZWVrbHlSZXBvcnRbXSB7XG4gIHJldHVybiB0ZW1wV2Vla2x5UmVwb3J0cy5maWx0ZXIocmVwb3J0ID0+IFxuICAgIHJlcG9ydC53ZWVrU3RhcnQgPj0gc3RhcnREYXRlICYmIHJlcG9ydC53ZWVrRW5kIDw9IGVuZERhdGVcbiAgKVxufVxuXG4vLyBEYXRlIHV0aWxpdHkgZnVuY3Rpb25zXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q3VycmVudFdlZWtTdGFydCgpOiBEYXRlIHtcbiAgY29uc3Qgbm93ID0gbmV3IERhdGUoKVxuICBjb25zdCBtb25kYXkgPSBuZXcgRGF0ZShub3cpXG4gIGNvbnN0IGRheSA9IG5vdy5nZXREYXkoKVxuICBjb25zdCBkaWZmID0gbm93LmdldERhdGUoKSAtIGRheSArIChkYXkgPT09IDAgPyAtNiA6IDEpIC8vIEFkanVzdCBmb3IgU3VuZGF5XG4gIG1vbmRheS5zZXREYXRlKGRpZmYpXG4gIG1vbmRheS5zZXRIb3VycygwLCAwLCAwLCAwKVxuICByZXR1cm4gbW9uZGF5XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDdXJyZW50V2Vla0VuZCgpOiBEYXRlIHtcbiAgY29uc3Qgd2Vla1N0YXJ0ID0gZ2V0Q3VycmVudFdlZWtTdGFydCgpXG4gIGNvbnN0IHdlZWtFbmQgPSBuZXcgRGF0ZSh3ZWVrU3RhcnQpXG4gIHdlZWtFbmQuc2V0RGF0ZSh3ZWVrU3RhcnQuZ2V0RGF0ZSgpICsgNilcbiAgd2Vla0VuZC5zZXRIb3VycygyMywgNTksIDU5LCA5OTkpXG4gIHJldHVybiB3ZWVrRW5kXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjYW5TdWJtaXRUaGlzV2Vlayh1c2VySWQ6IHN0cmluZyk6IGJvb2xlYW4ge1xuICBjb25zdCB3ZWVrU3RhcnQgPSBnZXRDdXJyZW50V2Vla1N0YXJ0KClcbiAgY29uc3Qgd2Vla0VuZCA9IGdldEN1cnJlbnRXZWVrRW5kKClcbiAgY29uc3QgY3VycmVudERhdGUgPSBuZXcgRGF0ZSgpXG4gIGNvbnN0IGV4aXN0aW5nUmVwb3J0ID0gZmluZFdlZWtseVJlcG9ydEJ5VXNlckFuZFdlZWsodXNlcklkLCB3ZWVrU3RhcnQpXG4gIFxuICAvLyBDYW4gc3VibWl0IGlmOlxuICAvLyAxLiBXZSBhcmUgY3VycmVudGx5IGluIHRoaXMgd2VlayAoY3VycmVudERhdGUgaXMgYmV0d2VlbiB3ZWVrU3RhcnQgYW5kIHdlZWtFbmQpXG4gIC8vIDIuIE5vIHJlcG9ydCBleGlzdHMgZm9yIHRoaXMgd2Vla1xuICBjb25zdCBpc0N1cnJlbnRXZWVrID0gY3VycmVudERhdGUgPj0gd2Vla1N0YXJ0ICYmIGN1cnJlbnREYXRlIDw9IHdlZWtFbmRcbiAgXG4gIGNvbnNvbGUubG9nKGDwn5SNIERlYnVnIGNhblN1Ym1pdFRoaXNXZWVrIGZvciB1c2VyICR7dXNlcklkfTpgKVxuICBjb25zb2xlLmxvZyhgICBDdXJyZW50IGRhdGU6ICR7Y3VycmVudERhdGUudG9JU09TdHJpbmcoKX1gKVxuICBjb25zb2xlLmxvZyhgICBXZWVrIHN0YXJ0OiAke3dlZWtTdGFydC50b0lTT1N0cmluZygpfWApXG4gIGNvbnNvbGUubG9nKGAgIFdlZWsgZW5kOiAke3dlZWtFbmQudG9JU09TdHJpbmcoKX1gKVxuICBjb25zb2xlLmxvZyhgICBJcyBjdXJyZW50IHdlZWs6ICR7aXNDdXJyZW50V2Vla31gKVxuICBjb25zb2xlLmxvZyhgICBFeGlzdGluZyByZXBvcnQ6ICR7ZXhpc3RpbmdSZXBvcnQgPyAnWUVTJyA6ICdOTyd9YClcbiAgY29uc29sZS5sb2coYCAgQ2FuIHN1Ym1pdDogJHtpc0N1cnJlbnRXZWVrICYmICFleGlzdGluZ1JlcG9ydH1gKVxuICBcbiAgcmV0dXJuIGlzQ3VycmVudFdlZWsgJiYgIWV4aXN0aW5nUmVwb3J0XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRXZWVrRGF0ZXMoZGF0ZTogRGF0ZSk6IHsgc3RhcnQ6IERhdGU7IGVuZDogRGF0ZSB9IHtcbiAgY29uc3Qgc3RhcnQgPSBuZXcgRGF0ZShkYXRlKVxuICBjb25zdCBkYXkgPSBzdGFydC5nZXREYXkoKVxuICBjb25zdCBkaWZmID0gc3RhcnQuZ2V0RGF0ZSgpIC0gZGF5ICsgKGRheSA9PT0gMCA/IC02IDogMSlcbiAgc3RhcnQuc2V0RGF0ZShkaWZmKVxuICBzdGFydC5zZXRIb3VycygwLCAwLCAwLCAwKVxuICBcbiAgY29uc3QgZW5kID0gbmV3IERhdGUoc3RhcnQpXG4gIGVuZC5zZXREYXRlKHN0YXJ0LmdldERhdGUoKSArIDYpXG4gIGVuZC5zZXRIb3VycygyMywgNTksIDU5LCA5OTkpXG4gIFxuICByZXR1cm4geyBzdGFydCwgZW5kIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldE1vbnRoV2Vla3MoeWVhcjogbnVtYmVyLCBtb250aDogbnVtYmVyKTogQXJyYXk8eyBzdGFydDogRGF0ZTsgZW5kOiBEYXRlIH0+IHtcbiAgY29uc3Qgd2Vla3MgPSBbXVxuICBjb25zdCBmaXJzdERheSA9IG5ldyBEYXRlKHllYXIsIG1vbnRoLCAxKVxuICBjb25zdCBsYXN0RGF5ID0gbmV3IERhdGUoeWVhciwgbW9udGggKyAxLCAwKVxuICBcbiAgbGV0IGN1cnJlbnQgPSBuZXcgRGF0ZShmaXJzdERheSlcbiAgXG4gIC8vIEFkanVzdCB0byBzdGFydCBmcm9tIE1vbmRheSBvZiBmaXJzdCB3ZWVrXG4gIGNvbnN0IGRheU9mV2VlayA9IGN1cnJlbnQuZ2V0RGF5KClcbiAgY29uc3QgZGF5c1RvU3VidHJhY3QgPSBkYXlPZldlZWsgPT09IDAgPyA2IDogZGF5T2ZXZWVrIC0gMVxuICBjdXJyZW50LnNldERhdGUoY3VycmVudC5nZXREYXRlKCkgLSBkYXlzVG9TdWJ0cmFjdClcbiAgXG4gIHdoaWxlIChjdXJyZW50IDw9IGxhc3REYXkpIHtcbiAgICBjb25zdCB3ZWVrU3RhcnQgPSBuZXcgRGF0ZShjdXJyZW50KVxuICAgIGNvbnN0IHdlZWtFbmQgPSBuZXcgRGF0ZShjdXJyZW50KVxuICAgIHdlZWtFbmQuc2V0RGF0ZSh3ZWVrU3RhcnQuZ2V0RGF0ZSgpICsgNilcbiAgICBcbiAgICB3ZWVrcy5wdXNoKHsgc3RhcnQ6IHdlZWtTdGFydCwgZW5kOiB3ZWVrRW5kIH0pXG4gICAgY3VycmVudC5zZXREYXRlKGN1cnJlbnQuZ2V0RGF0ZSgpICsgNylcbiAgfVxuICBcbiAgcmV0dXJuIHdlZWtzXG59XG5cbi8vID09PT09IENBTEVOREFSIEZVTkNUSU9OUyA9PT09PVxuLy8gVGhlc2UgZnVuY3Rpb25zIGludGVncmF0ZSB3aXRoIHRoZSBjYWxlbmRhciBzeXN0ZW0gZm9yIFNhcmEgQUlcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEV2ZW50cyh1c2VySWQ6IHN0cmluZyk6IGFueVtdIHtcbiAgLy8gSW1wb3J0IGNhbGVuZGFyIGRhdGEgZnVuY3Rpb25zXG4gIHRyeSB7XG4gICAgY29uc3QgeyBnZXRVc2VyQ2FsZW5kYXJEYXRhIH0gPSByZXF1aXJlKCcuL2NhbGVuZGFyLWRhdGEnKVxuICAgIGNvbnN0IHVzZXJEYXRhID0gZ2V0VXNlckNhbGVuZGFyRGF0YSh1c2VySWQpXG4gICAgcmV0dXJuIHVzZXJEYXRhPy5ldmVudHMgfHwgW11cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIGNhbGVuZGFyIGV2ZW50czonLCBlcnJvcilcbiAgICByZXR1cm4gW11cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0QWxsQ2FsZW5kYXJFdmVudHModXNlcklkOiBzdHJpbmcpOiBhbnlbXSB7XG4gIC8vIEFsaWFzIGZvciBnZXRFdmVudHMgZm9yIGNvbXBhdGliaWxpdHlcbiAgcmV0dXJuIGdldEV2ZW50cyh1c2VySWQpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRVcGNvbWluZ0V2ZW50cyh1c2VySWQ6IHN0cmluZywgZGF5czogbnVtYmVyID0gMzApOiBhbnlbXSB7XG4gIHRyeSB7XG4gICAgY29uc3QgYWxsRXZlbnRzID0gZ2V0RXZlbnRzKHVzZXJJZClcbiAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpXG4gICAgY29uc3QgZnV0dXJlRGF0ZSA9IG5ldyBEYXRlKClcbiAgICBmdXR1cmVEYXRlLnNldERhdGUoZnV0dXJlRGF0ZS5nZXREYXRlKCkgKyBkYXlzKVxuICAgIFxuICAgIHJldHVybiBhbGxFdmVudHMuZmlsdGVyKGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IGV2ZW50RGF0ZSA9IG5ldyBEYXRlKGV2ZW50LmRhdGUpXG4gICAgICByZXR1cm4gZXZlbnREYXRlID49IG5vdyAmJiBldmVudERhdGUgPD0gZnV0dXJlRGF0ZVxuICAgIH0pLnNvcnQoKGEsIGIpID0+IG5ldyBEYXRlKGEuZGF0ZSkuZ2V0VGltZSgpIC0gbmV3IERhdGUoYi5kYXRlKS5nZXRUaW1lKCkpXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyB1cGNvbWluZyBldmVudHM6JywgZXJyb3IpXG4gICAgcmV0dXJuIFtdXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEV2ZW50c0ZvckRhdGVSYW5nZSh1c2VySWQ6IHN0cmluZywgc3RhcnREYXRlOiBEYXRlLCBlbmREYXRlOiBEYXRlKTogYW55W10ge1xuICB0cnkge1xuICAgIGNvbnN0IGFsbEV2ZW50cyA9IGdldEV2ZW50cyh1c2VySWQpXG4gICAgcmV0dXJuIGFsbEV2ZW50cy5maWx0ZXIoZXZlbnQgPT4ge1xuICAgICAgY29uc3QgZXZlbnREYXRlID0gbmV3IERhdGUoZXZlbnQuZGF0ZSlcbiAgICAgIHJldHVybiBldmVudERhdGUgPj0gc3RhcnREYXRlICYmIGV2ZW50RGF0ZSA8PSBlbmREYXRlXG4gICAgfSlcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIGV2ZW50cyBmb3IgZGF0ZSByYW5nZTonLCBlcnJvcilcbiAgICByZXR1cm4gW11cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZmluZEV2ZW50QnlJZCh1c2VySWQ6IHN0cmluZywgZXZlbnRJZDogc3RyaW5nKTogYW55IHwgbnVsbCB7XG4gIHRyeSB7XG4gICAgY29uc3QgYWxsRXZlbnRzID0gZ2V0RXZlbnRzKHVzZXJJZClcbiAgICByZXR1cm4gYWxsRXZlbnRzLmZpbmQoZXZlbnQgPT4gZXZlbnQuaWQgPT09IGV2ZW50SWQpIHx8IG51bGxcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmaW5kaW5nIGV2ZW50IGJ5IElEOicsIGVycm9yKVxuICAgIHJldHVybiBudWxsXG4gIH1cbn1cblxuLy8gPT09PT0gQ09OVkVSU0FUSU9OIE1FTU9SWSBGVU5DVElPTlMgPT09PT1cbi8vIFBlcnNpc3RlbnQgY29udmVyc2F0aW9uIHN0b3JhZ2UgZm9yIFNhcmEgQUlcblxuaW50ZXJmYWNlIENvbnZlcnNhdGlvblR1cm4ge1xuICBpZDogc3RyaW5nXG4gIHRpbWVzdGFtcDogRGF0ZVxuICByb2xlOiAndXNlcicgfCAnYXNzaXN0YW50J1xuICBjb250ZW50OiBzdHJpbmdcbiAgbWV0YWRhdGE6IHtcbiAgICBzdWJqZWN0Pzogc3RyaW5nXG4gICAgdG9waWM/OiBzdHJpbmdcbiAgICBpbnRlbnRpb24/OiBzdHJpbmdcbiAgICB0YXNrQ29tcGxldGVkPzogYm9vbGVhblxuICAgIGV2ZW50Q3JlYXRlZD86IGJvb2xlYW5cbiAgfVxufVxuXG5pbnRlcmZhY2UgQ29udmVyc2F0aW9uU2Vzc2lvbiB7XG4gIHVzZXJJZDogc3RyaW5nXG4gIHNlc3Npb25JZDogc3RyaW5nXG4gIHR1cm5zOiBDb252ZXJzYXRpb25UdXJuW11cbiAgY3VycmVudFRvcGljPzogc3RyaW5nXG4gIGN1cnJlbnRTdWJqZWN0Pzogc3RyaW5nXG4gIHBlbmRpbmdUYXNrczogQXJyYXk8e1xuICAgIGlkOiBzdHJpbmdcbiAgICB0eXBlOiAnY2FsZW5kYXJfZXZlbnQnIHwgJ2FjYWRlbWljX3NlYXJjaCcgfCAncmVtaW5kZXInXG4gICAgZGVzY3JpcHRpb246IHN0cmluZ1xuICAgIGRhdGE6IGFueVxuICAgIGNvbXBsZXRlZDogYm9vbGVhblxuICAgIGNyZWF0ZWRBdDogRGF0ZVxuICB9PlxuICBsYXN0VXBkYXRlOiBEYXRlXG59XG5cbi8vIEdsb2JhbCBzdG9yYWdlIGZvciBjb252ZXJzYXRpb25zXG5jb25zdCBnbG9iYWxGb3JDb252ZXJzYXRpb25zID0gZ2xvYmFsVGhpcyBhcyB1bmtub3duIGFzIHtcbiAgdGVtcENvbnZlcnNhdGlvbnM6IENvbnZlcnNhdGlvblNlc3Npb25bXSB8IHVuZGVmaW5lZFxufVxuXG5leHBvcnQgY29uc3QgdGVtcENvbnZlcnNhdGlvbnM6IENvbnZlcnNhdGlvblNlc3Npb25bXSA9IGdsb2JhbEZvckNvbnZlcnNhdGlvbnMudGVtcENvbnZlcnNhdGlvbnMgPz8gW11cbmdsb2JhbEZvckNvbnZlcnNhdGlvbnMudGVtcENvbnZlcnNhdGlvbnMgPSB0ZW1wQ29udmVyc2F0aW9uc1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29udmVyc2F0aW9uU2Vzc2lvbih1c2VySWQ6IHN0cmluZywgc2Vzc2lvbklkOiBzdHJpbmcpOiBDb252ZXJzYXRpb25TZXNzaW9uIHwgbnVsbCB7XG4gIHJldHVybiB0ZW1wQ29udmVyc2F0aW9ucy5maW5kKHNlc3Npb24gPT4gXG4gICAgc2Vzc2lvbi51c2VySWQgPT09IHVzZXJJZCAmJiBzZXNzaW9uLnNlc3Npb25JZCA9PT0gc2Vzc2lvbklkXG4gICkgfHwgbnVsbFxufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ29udmVyc2F0aW9uU2Vzc2lvbih1c2VySWQ6IHN0cmluZywgc2Vzc2lvbklkOiBzdHJpbmcpOiBDb252ZXJzYXRpb25TZXNzaW9uIHtcbiAgLy8gRmlyc3QgcmVtb3ZlIGFueSBvbGQgc2Vzc2lvbiBmb3IgdGhlIHNhbWUgdXNlci9zZXNzaW9uSWRcbiAgY29uc3QgZXhpc3RpbmdJbmRleCA9IHRlbXBDb252ZXJzYXRpb25zLmZpbmRJbmRleChzZXNzaW9uID0+IFxuICAgIHNlc3Npb24udXNlcklkID09PSB1c2VySWQgJiYgc2Vzc2lvbi5zZXNzaW9uSWQgPT09IHNlc3Npb25JZFxuICApXG4gIGlmIChleGlzdGluZ0luZGV4ICE9PSAtMSkge1xuICAgIHRlbXBDb252ZXJzYXRpb25zLnNwbGljZShleGlzdGluZ0luZGV4LCAxKVxuICB9XG5cbiAgY29uc3QgbmV3U2Vzc2lvbjogQ29udmVyc2F0aW9uU2Vzc2lvbiA9IHtcbiAgICB1c2VySWQsXG4gICAgc2Vzc2lvbklkLFxuICAgIHR1cm5zOiBbXSxcbiAgICBjdXJyZW50VG9waWM6IHVuZGVmaW5lZCxcbiAgICBjdXJyZW50U3ViamVjdDogdW5kZWZpbmVkLFxuICAgIHBlbmRpbmdUYXNrczogW10sXG4gICAgbGFzdFVwZGF0ZTogbmV3IERhdGUoKVxuICB9XG4gIFxuICB0ZW1wQ29udmVyc2F0aW9ucy5wdXNoKG5ld1Nlc3Npb24pXG4gIGNvbnNvbGUubG9nKGDwn5KsIENyZWF0ZWQgY29udmVyc2F0aW9uIHNlc3Npb24gJHtzZXNzaW9uSWR9IGZvciB1c2VyICR7dXNlcklkfWApXG4gIHJldHVybiBuZXdTZXNzaW9uXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVDb252ZXJzYXRpb25TZXNzaW9uKHNlc3Npb246IENvbnZlcnNhdGlvblNlc3Npb24pOiBDb252ZXJzYXRpb25TZXNzaW9uIHtcbiAgY29uc3QgaW5kZXggPSB0ZW1wQ29udmVyc2F0aW9ucy5maW5kSW5kZXgocyA9PiBcbiAgICBzLnVzZXJJZCA9PT0gc2Vzc2lvbi51c2VySWQgJiYgcy5zZXNzaW9uSWQgPT09IHNlc3Npb24uc2Vzc2lvbklkXG4gIClcbiAgXG4gIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICB0ZW1wQ29udmVyc2F0aW9uc1tpbmRleF0gPSB7IC4uLnNlc3Npb24sIGxhc3RVcGRhdGU6IG5ldyBEYXRlKCkgfVxuICAgIGNvbnNvbGUubG9nKGDwn5KsIFVwZGF0ZWQgc2Vzc2lvbiAke3Nlc3Npb24uc2Vzc2lvbklkfSAtICR7c2Vzc2lvbi50dXJucy5sZW5ndGh9IHR1cm5zYClcbiAgfSBlbHNlIHtcbiAgICB0ZW1wQ29udmVyc2F0aW9ucy5wdXNoKHsgLi4uc2Vzc2lvbiwgbGFzdFVwZGF0ZTogbmV3IERhdGUoKSB9KVxuICAgIGNvbnNvbGUubG9nKGDwn5KsIENyZWF0ZWQgbmV3IHNlc3Npb24gJHtzZXNzaW9uLnNlc3Npb25JZH0gZHVyaW5nIHVwZGF0ZWApXG4gIH1cbiAgXG4gIHJldHVybiBzZXNzaW9uXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRDb252ZXJzYXRpb25UdXJuKFxuICB1c2VySWQ6IHN0cmluZywgXG4gIHNlc3Npb25JZDogc3RyaW5nLCBcbiAgcm9sZTogJ3VzZXInIHwgJ2Fzc2lzdGFudCcsIFxuICBjb250ZW50OiBzdHJpbmcsXG4gIG1ldGFkYXRhOiBDb252ZXJzYXRpb25UdXJuWydtZXRhZGF0YSddID0ge31cbik6IENvbnZlcnNhdGlvblNlc3Npb24ge1xuICBsZXQgc2Vzc2lvbiA9IGdldENvbnZlcnNhdGlvblNlc3Npb24odXNlcklkLCBzZXNzaW9uSWQpXG4gIGlmICghc2Vzc2lvbikge1xuICAgIHNlc3Npb24gPSBjcmVhdGVDb252ZXJzYXRpb25TZXNzaW9uKHVzZXJJZCwgc2Vzc2lvbklkKVxuICB9XG4gIFxuICBjb25zdCB0dXJuOiBDb252ZXJzYXRpb25UdXJuID0ge1xuICAgIGlkOiBgdHVybl8ke0RhdGUubm93KCl9XyR7TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIDkpfWAsXG4gICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLFxuICAgIHJvbGUsXG4gICAgY29udGVudCxcbiAgICBtZXRhZGF0YVxuICB9XG4gIFxuICBzZXNzaW9uLnR1cm5zLnB1c2godHVybilcbiAgXG4gIC8vIEtlZXAgb25seSBsYXN0IDIwIHR1cm5zIHBlciBzZXNzaW9uXG4gIGlmIChzZXNzaW9uLnR1cm5zLmxlbmd0aCA+IDIwKSB7XG4gICAgc2Vzc2lvbi50dXJucyA9IHNlc3Npb24udHVybnMuc2xpY2UoLTIwKVxuICB9XG4gIFxuICByZXR1cm4gdXBkYXRlQ29udmVyc2F0aW9uU2Vzc2lvbihzZXNzaW9uKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYWRkUGVuZGluZ1Rhc2soXG4gIHVzZXJJZDogc3RyaW5nLFxuICBzZXNzaW9uSWQ6IHN0cmluZyxcbiAgdHlwZTogJ2NhbGVuZGFyX2V2ZW50JyB8ICdhY2FkZW1pY19zZWFyY2gnIHwgJ3JlbWluZGVyJyxcbiAgZGVzY3JpcHRpb246IHN0cmluZyxcbiAgZGF0YTogYW55XG4pOiB2b2lkIHtcbiAgbGV0IHNlc3Npb24gPSBnZXRDb252ZXJzYXRpb25TZXNzaW9uKHVzZXJJZCwgc2Vzc2lvbklkKVxuICBpZiAoIXNlc3Npb24pIHtcbiAgICBzZXNzaW9uID0gY3JlYXRlQ29udmVyc2F0aW9uU2Vzc2lvbih1c2VySWQsIHNlc3Npb25JZClcbiAgfVxuICBcbiAgY29uc3QgdGFzayA9IHtcbiAgICBpZDogYHRhc2tfJHtEYXRlLm5vdygpfWAsXG4gICAgdHlwZSxcbiAgICBkZXNjcmlwdGlvbixcbiAgICBkYXRhLFxuICAgIGNvbXBsZXRlZDogZmFsc2UsXG4gICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpXG4gIH1cbiAgXG4gIHNlc3Npb24ucGVuZGluZ1Rhc2tzLnB1c2godGFzaylcbiAgY29uc29sZS5sb2coYPCfk4sgQWRkZWQgcGVuZGluZyB0YXNrOiAke2Rlc2NyaXB0aW9ufWApXG4gIFxuICB1cGRhdGVDb252ZXJzYXRpb25TZXNzaW9uKHNlc3Npb24pXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYXJrVGFza0NvbXBsZXRlZChcbiAgdXNlcklkOiBzdHJpbmcsXG4gIHNlc3Npb25JZDogc3RyaW5nLFxuICB0YXNrSWQ6IHN0cmluZyxcbiAgcmVzdWx0PzogYW55XG4pOiBib29sZWFuIHtcbiAgY29uc3Qgc2Vzc2lvbiA9IGdldENvbnZlcnNhdGlvblNlc3Npb24odXNlcklkLCBzZXNzaW9uSWQpXG4gIGlmICghc2Vzc2lvbikgcmV0dXJuIGZhbHNlXG4gIFxuICBjb25zdCB0YXNrID0gc2Vzc2lvbi5wZW5kaW5nVGFza3MuZmluZCh0ID0+IHQuaWQgPT09IHRhc2tJZClcbiAgaWYgKCF0YXNrKSByZXR1cm4gZmFsc2VcbiAgXG4gIHRhc2suY29tcGxldGVkID0gdHJ1ZVxuICBpZiAocmVzdWx0KSB7XG4gICAgdGFzay5kYXRhLnJlc3VsdCA9IHJlc3VsdFxuICB9XG4gIFxuICBjb25zb2xlLmxvZyhg4pyFIENvbXBsZXRlZCB0YXNrOiAke3Rhc2suZGVzY3JpcHRpb259YClcbiAgdXBkYXRlQ29udmVyc2F0aW9uU2Vzc2lvbihzZXNzaW9uKVxuICByZXR1cm4gdHJ1ZVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UGVuZGluZ1Rhc2tzKHVzZXJJZDogc3RyaW5nLCBzZXNzaW9uSWQ6IHN0cmluZyk6IEFycmF5PHtcbiAgaWQ6IHN0cmluZ1xuICB0eXBlOiAnY2FsZW5kYXJfZXZlbnQnIHwgJ2FjYWRlbWljX3NlYXJjaCcgfCAncmVtaW5kZXInXG4gIGRlc2NyaXB0aW9uOiBzdHJpbmdcbiAgZGF0YTogYW55XG4gIGNvbXBsZXRlZDogYm9vbGVhblxuICBjcmVhdGVkQXQ6IERhdGVcbn0+IHtcbiAgY29uc3Qgc2Vzc2lvbiA9IGdldENvbnZlcnNhdGlvblNlc3Npb24odXNlcklkLCBzZXNzaW9uSWQpXG4gIGlmICghc2Vzc2lvbikgcmV0dXJuIFtdXG4gIFxuICByZXR1cm4gc2Vzc2lvbi5wZW5kaW5nVGFza3MuZmlsdGVyKHRhc2sgPT4gIXRhc2suY29tcGxldGVkKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29udmVyc2F0aW9uSGlzdG9yeSh1c2VySWQ6IHN0cmluZywgc2Vzc2lvbklkOiBzdHJpbmcsIGxpbWl0OiBudW1iZXIgPSAxMCk6IENvbnZlcnNhdGlvblR1cm5bXSB7XG4gIGNvbnN0IHNlc3Npb24gPSBnZXRDb252ZXJzYXRpb25TZXNzaW9uKHVzZXJJZCwgc2Vzc2lvbklkKVxuICBpZiAoIXNlc3Npb24pIHJldHVybiBbXVxuICBcbiAgcmV0dXJuIHNlc3Npb24udHVybnMuc2xpY2UoLWxpbWl0KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VXNlckFjdGl2ZVNlc3Npb25zKHVzZXJJZDogc3RyaW5nKTogQ29udmVyc2F0aW9uU2Vzc2lvbltdIHtcbiAgY29uc3Qgb25lSG91ckFnbyA9IG5ldyBEYXRlKERhdGUubm93KCkgLSAoNjAgKiA2MCAqIDEwMDApKVxuICByZXR1cm4gdGVtcENvbnZlcnNhdGlvbnMuZmlsdGVyKHNlc3Npb24gPT4gXG4gICAgc2Vzc2lvbi51c2VySWQgPT09IHVzZXJJZCAmJiBzZXNzaW9uLmxhc3RVcGRhdGUgPiBvbmVIb3VyQWdvXG4gIClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNsZWFudXBPbGRDb252ZXJzYXRpb25zKCk6IHZvaWQge1xuICBjb25zdCBzaXhIb3Vyc0FnbyA9IG5ldyBEYXRlKERhdGUubm93KCkgLSAoNiAqIDYwICogNjAgKiAxMDAwKSlcbiAgY29uc3QgYmVmb3JlID0gdGVtcENvbnZlcnNhdGlvbnMubGVuZ3RoXG4gIFxuICAvLyBSZW1vdmUgY29udmVyc2F0aW9ucyBvbGRlciB0aGFuIDYgaG91cnNcbiAgZm9yIChsZXQgaSA9IHRlbXBDb252ZXJzYXRpb25zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKHRlbXBDb252ZXJzYXRpb25zW2ldLmxhc3RVcGRhdGUgPCBzaXhIb3Vyc0Fnbykge1xuICAgICAgdGVtcENvbnZlcnNhdGlvbnMuc3BsaWNlKGksIDEpXG4gICAgfVxuICB9XG4gIFxuICBjb25zdCBhZnRlciA9IHRlbXBDb252ZXJzYXRpb25zLmxlbmd0aFxuICBpZiAoYmVmb3JlICE9PSBhZnRlcikge1xuICAgIGNvbnNvbGUubG9nKGDwn6e5IENsZWFuZWQgdXAgJHtiZWZvcmUgLSBhZnRlcn0gb2xkIGNvbnZlcnNhdGlvbiBzZXNzaW9uc2ApXG4gIH1cbn1cblxuLy8gSW5pdGlhbGl6ZSBkZWZhdWx0IHVzZXJzIGF1dG9tYXRpY2FsbHlcbmltcG9ydCBiY3J5cHQgZnJvbSBcImJjcnlwdGpzXCJcblxuZnVuY3Rpb24gaW5pdERlZmF1bHRVc2VycygpIHtcbiAgLy8gQ2hlY2sgaWYgZGVtbyB1c2VycyBhbHJlYWR5IGV4aXN0IHRvIGF2b2lkIGR1cGxpY2F0ZXNcbiAgY29uc3Qgc3R1ZGVudEV4aXN0cyA9IGZpbmRVc2VyQnlFbWFpbChcImVzdHVkaWFudGVAZGVtby5jb21cIilcbiAgY29uc3QgaW5zdHJ1Y3RvckV4aXN0cyA9IGZpbmRVc2VyQnlFbWFpbChcImluc3RydWN0b3JAZGVtby5jb21cIilcbiAgXG4gIGlmICghc3R1ZGVudEV4aXN0cyB8fCAhaW5zdHJ1Y3RvckV4aXN0cykge1xuICAgIGNvbnNvbGUubG9nKFwi8J+UpyBJbmljaWFsaXphbmRvIHVzdWFyaW9zIHBvciBkZWZlY3RvLi4uXCIpXG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGhhc2hlZFBhc3N3b3JkID0gYmNyeXB0Lmhhc2hTeW5jKFwiRXN0dWRpYW50ZTEyMyEhIVwiLCAxMilcbiAgICAgIFxuICAgICAgLy8gT25seSBhZGQgc3R1ZGVudCBpZiBkb2Vzbid0IGV4aXN0XG4gICAgICBpZiAoIXN0dWRlbnRFeGlzdHMpIHtcbiAgICAgICAgYWRkVXNlcih7XG4gICAgICAgICAgaWQ6IFwiZGVtby1zdHVkZW50LWZpeGVkXCIsXG4gICAgICAgICAgbmFtZTogXCJFc3R1ZGlhbnRlIERlbW9cIixcbiAgICAgICAgICBlbWFpbDogXCJlc3R1ZGlhbnRlQGRlbW8uY29tXCIsXG4gICAgICAgICAgcGFzc3dvcmQ6IGhhc2hlZFBhc3N3b3JkLFxuICAgICAgICAgIHJvbGU6IFwiU1RVREVOVFwiLFxuICAgICAgICAgIHN0dWRlbnRJZDogXCJFU1QtMjAyNS0wMDFcIixcbiAgICAgICAgICBzdGF0dXM6IFwiQUNUSVZFXCIsXG4gICAgICAgICAgZW5yb2xsbWVudFllYXI6IDIwMjUsXG4gICAgICAgICAgYWNhZGVtaWNZZWFyOiBcIjIwMjUtMjAyNlwiLFxuICAgICAgICAgIHByb2dyYW06IFwiSW5nZW5pZXLDrWEgZW4gU2lzdGVtYXNcIixcbiAgICAgICAgICBwaG9uZU51bWJlcjogXCIrMTIzNDU2Nzg5MFwiLFxuICAgICAgICAgIGRhdGVPZkJpcnRoOiBuZXcgRGF0ZShcIjIwMDAtMDEtMDFcIiksXG4gICAgICAgICAgYWRkcmVzczogXCJEZW1vIEFkZHJlc3MgMTIzXCIsXG4gICAgICAgICAgZW1lcmdlbmN5Q29udGFjdDoge1xuICAgICAgICAgICAgbmFtZTogXCJDb250YWN0byBEZW1vXCIsXG4gICAgICAgICAgICBwaG9uZTogXCIrMDk4NzY1NDMyMVwiLFxuICAgICAgICAgICAgcmVsYXRpb25zaGlwOiBcIlBhZHJlXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKSxcbiAgICAgICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKCksXG4gICAgICAgIH0pXG4gICAgICAgIGNvbnNvbGUubG9nKFwi4pyFIFVzdWFyaW8gZXN0dWRpYW50ZSBkZW1vIGNyZWFkb1wiKVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBPbmx5IGFkZCBpbnN0cnVjdG9yIGlmIGRvZXNuJ3QgZXhpc3RcbiAgICAgIGlmICghaW5zdHJ1Y3RvckV4aXN0cykge1xuICAgICAgICBhZGRVc2VyKHtcbiAgICAgICAgICBpZDogXCJkZW1vLWluc3RydWN0b3ItZml4ZWRcIixcbiAgICAgICAgICBuYW1lOiBcIkluc3RydWN0b3IgRGVtb1wiLFxuICAgICAgICAgIGVtYWlsOiBcImluc3RydWN0b3JAZGVtby5jb21cIixcbiAgICAgICAgICBwYXNzd29yZDogaGFzaGVkUGFzc3dvcmQsXG4gICAgICAgICAgcm9sZTogXCJJTlNUUlVDVE9SXCIsXG4gICAgICAgICAgc3R1ZGVudElkOiBudWxsLFxuICAgICAgICAgIHN0YXR1czogXCJBQ1RJVkVcIixcbiAgICAgICAgICBlbnJvbGxtZW50WWVhcjogMjAyNSxcbiAgICAgICAgICBhY2FkZW1pY1llYXI6IFwiMjAyNS0yMDI2XCIsXG4gICAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLFxuICAgICAgICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoKSxcbiAgICAgICAgfSlcbiAgICAgICAgY29uc29sZS5sb2coXCLinIUgVXN1YXJpbyBpbnN0cnVjdG9yIGRlbW8gY3JlYWRvXCIpXG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKFwi4pyFIFZlcmlmaWNhY2nDs24gZGUgdXN1YXJpb3MgcG9yIGRlZmVjdG8gY29tcGxldGFkYVwiKVxuICAgICAgXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCLinYwgRXJyb3IgY3JlYW5kbyB1c3VhcmlvcyBwb3IgZGVmZWN0bzpcIiwgZXJyb3IpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnNvbGUubG9nKFwi4pyFIFVzdWFyaW9zIGRlbW8geWEgZXhpc3Rlbiwgbm8gc2UgcmVpbmljaWFsaXphblwiKVxuICB9XG4gIFxuICAvLyBBbHdheXMgY2hlY2sgYW5kIGluaXRpYWxpemUgc2FtcGxlIHJlcG9ydHNcbiAgaW5pdFNhbXBsZVJlcG9ydHMoKVxufVxuXG5mdW5jdGlvbiBpbml0U2FtcGxlUmVwb3J0cygpIHtcbiAgLy8gQ2hlY2sgaWYgc2FtcGxlIHJlcG9ydHMgYWxyZWFkeSBleGlzdCBmb3IgZGVtbyBzdHVkZW50XG4gIGNvbnN0IGV4aXN0aW5nU2FtcGxlUmVwb3J0cyA9IHRlbXBXZWVrbHlSZXBvcnRzLmZpbHRlcihyZXBvcnQgPT4gcmVwb3J0LnVzZXJJZCA9PT0gXCJkZW1vLXN0dWRlbnQtZml4ZWRcIilcbiAgXG4gIGlmIChleGlzdGluZ1NhbXBsZVJlcG9ydHMubGVuZ3RoID09PSAwKSB7XG4gICAgY29uc29sZS5sb2coXCLwn5OdIEluaWNpYWxpemFuZG8gcmVwb3J0ZXMgZGUgbXVlc3RyYS4uLlwiKVxuICAgIFxuICAgIHRyeSB7XG4gICAgICAvLyBHZXQgY3VycmVudCB3ZWVrIGRhdGVzXG4gICAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpXG4gICAgICBjb25zdCBjdXJyZW50V2VlayA9IGdldEN1cnJlbnRXZWVrU3RhcnQoKVxuICAgICAgY29uc3QgY3VycmVudFdlZWtFbmQgPSBnZXRDdXJyZW50V2Vla0VuZCgpXG4gICAgICBcbiAgICAgIC8vIFByZXZpb3VzIHdlZWtcbiAgICAgIGNvbnN0IHByZXZXZWVrID0gbmV3IERhdGUoY3VycmVudFdlZWspXG4gICAgICBwcmV2V2Vlay5zZXREYXRlKHByZXZXZWVrLmdldERhdGUoKSAtIDcpXG4gICAgICBjb25zdCBwcmV2V2Vla0VuZCA9IG5ldyBEYXRlKGN1cnJlbnRXZWVrRW5kKVxuICAgICAgcHJldldlZWtFbmQuc2V0RGF0ZShwcmV2V2Vla0VuZC5nZXREYXRlKCkgLSA3KVxuICAgICAgXG4gICAgICAvLyBTYW1wbGUgcmVwb3J0IGZyb20gcHJldmlvdXMgd2Vla1xuICAgICAgYWRkV2Vla2x5UmVwb3J0KHtcbiAgICAgICAgaWQ6IFwic2FtcGxlLXJlcG9ydC0xXCIsXG4gICAgICAgIHVzZXJJZDogXCJkZW1vLXN0dWRlbnQtZml4ZWRcIixcbiAgICAgICAgd2Vla1N0YXJ0OiBwcmV2V2VlayxcbiAgICAgICAgd2Vla0VuZDogcHJldldlZWtFbmQsXG4gICAgICAgIHN1Ym1pdHRlZEF0OiBuZXcgRGF0ZShwcmV2V2Vla0VuZC5nZXRUaW1lKCkgLSAyNCAqIDYwICogNjAgKiAxMDAwKSwgLy8gMSBkYXkgYmVmb3JlIHdlZWsgZW5kXG4gICAgICAgIHJlc3BvbnNlczoge1xuICAgICAgICAgIHRlbWFzWURvbWluaW86IFwiRXN0YSBzZW1hbmEgdHJhYmFqYW1vcyBjb24gSmF2YVNjcmlwdCBiw6FzaWNvIC0gTml2ZWwgMzogRG9taW5vIGZ1bmNpb25lcyB5IGFycmF5cywgeSBlc3RveSBhcHJlbmRpZW5kbyBvYmpldG9zIGNvbXBsZWpvcy5cIixcbiAgICAgICAgICBldmlkZW5jaWFBcHJlbmRpemFqZTogXCJDb21wbGV0w6kgdW4gcHJveWVjdG8gZGUgVG8tRG8gTGlzdCB1c2FuZG8gSmF2YVNjcmlwdCB2YW5pbGxhLiBJbXBsZW1lbnTDqSBmdW5jaW9uZXMgcGFyYSBhZ3JlZ2FyLCBlZGl0YXIgeSBlbGltaW5hciB0YXJlYXMgdXNhbmRvIGFycmF5cyB5IG9iamV0b3MuXCIsXG4gICAgICAgICAgZGlmaWN1bHRhZGVzRXN0cmF0ZWdpYXM6IFwiVHV2ZSBkaWZpY3VsdGFkZXMgY29uIGVsIG1hbmVqbyBkZSBldmVudG9zIGVuIEphdmFTY3JpcHQuIExvIHJlc29sdsOtIHByYWN0aWNhbmRvIGNvbiBlamVtcGxvcyB5IGNvbnN1bHRhbmRvIGRvY3VtZW50YWNpw7NuIGRlIE1ETi5cIixcbiAgICAgICAgICBjb25leGlvbmVzQXBsaWNhY2lvbjogXCJMb3MgY29uY2VwdG9zIGRlIGV2ZW50b3Mgc2UgY29uZWN0YW4gY29uIGxhIGludGVyYWN0aXZpZGFkIGVuIGFwbGljYWNpb25lcyB3ZWIuIFB1ZWRvIGFwbGljYXJsbyBwYXJhIGNyZWFyIGludGVyZmFjZXMgbcOhcyBkaW7DoW1pY2FzLlwiLFxuICAgICAgICAgIGNvbWVudGFyaW9zQWRpY2lvbmFsZXM6IFwiTWUgc2llbnRvIG3DoXMgY29uZmlhZG8gY29uIEphdmFTY3JpcHQuIFF1aWVybyBzZWd1aXIgcHJhY3RpY2FuZG8gY29uIHByb3llY3RvcyBtw6FzIGNvbXBsZWpvcy5cIlxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgXG4gICAgICAvLyBUd28gd2Vla3MgYWdvIHJlcG9ydCAgXG4gICAgICBjb25zdCB0d29XZWVrc0FnbyA9IG5ldyBEYXRlKGN1cnJlbnRXZWVrKVxuICAgICAgdHdvV2Vla3NBZ28uc2V0RGF0ZSh0d29XZWVrc0Fnby5nZXREYXRlKCkgLSAxNClcbiAgICAgIGNvbnN0IHR3b1dlZWtzQWdvRW5kID0gbmV3IERhdGUoY3VycmVudFdlZWtFbmQpXG4gICAgICB0d29XZWVrc0Fnb0VuZC5zZXREYXRlKHR3b1dlZWtzQWdvRW5kLmdldERhdGUoKSAtIDE0KVxuICAgICAgXG4gICAgICBhZGRXZWVrbHlSZXBvcnQoe1xuICAgICAgICBpZDogXCJzYW1wbGUtcmVwb3J0LTJcIixcbiAgICAgICAgdXNlcklkOiBcImRlbW8tc3R1ZGVudC1maXhlZFwiLCBcbiAgICAgICAgd2Vla1N0YXJ0OiB0d29XZWVrc0FnbyxcbiAgICAgICAgd2Vla0VuZDogdHdvV2Vla3NBZ29FbmQsXG4gICAgICAgIHN1Ym1pdHRlZEF0OiBuZXcgRGF0ZSh0d29XZWVrc0Fnb0VuZC5nZXRUaW1lKCkgLSAxMiAqIDYwICogNjAgKiAxMDAwKSwgLy8gMTIgaG91cnMgYmVmb3JlIHdlZWsgZW5kXG4gICAgICAgIHJlc3BvbnNlczoge1xuICAgICAgICAgIHRlbWFzWURvbWluaW86IFwiRXN0YSBzZW1hbmEgZXN0dWRpYW1vcyBDU1MgR3JpZCB5IEZsZXhib3ggLSBOaXZlbCAyOiBFbnRpZW5kbyBsb3MgY29uY2VwdG9zIGLDoXNpY29zIHBlcm8gYcO6biB0ZW5nbyBkdWRhcyBjb24gbGF5b3V0cyBjb21wbGVqb3MuXCIsXG4gICAgICAgICAgZXZpZGVuY2lhQXByZW5kaXphamU6IFwiUmVjcmXDqSBlbCBsYXlvdXQgZGUgdW5hIHDDoWdpbmEgd2ViIHVzYW5kbyBDU1MgR3JpZC4gTG9ncsOpIGhhY2VyIHVuYSBlc3RydWN0dXJhIHJlc3BvbnNpdmUgY29uIGhlYWRlciwgc2lkZWJhciB5IG1haW4gY29udGVudC5cIixcbiAgICAgICAgICBkaWZpY3VsdGFkZXNFc3RyYXRlZ2lhczogXCJNZSBjb25mdW5kw60gY29uIGxhcyBwcm9waWVkYWRlcyBncmlkLXRlbXBsYXRlLWFyZWFzLiBSZXNvbHbDrSBlbCBwcm9ibGVtYSBkaWJ1amFuZG8gZWwgbGF5b3V0IGVuIHBhcGVsIHByaW1lcm8uXCIsXG4gICAgICAgICAgY29uZXhpb25lc0FwbGljYWNpb246IFwiQ1NTIEdyaWQgZXMgcGVyZmVjdG8gcGFyYSBjcmVhciBsYXlvdXRzIGRlIHDDoWdpbmFzIHdlYiBtb2Rlcm5hcy4gTG8gdXNhcsOpIGVuIG1pIHByb3llY3RvIGZpbmFsIGRlIHDDoWdpbmEgcG9ydGZvbGlvLlwiLFxuICAgICAgICAgIGNvbWVudGFyaW9zQWRpY2lvbmFsZXM6IFwiQ1NTIGVzIG3DoXMgZGl2ZXJ0aWRvIGRlIGxvIHF1ZSBwZW5zYWJhLiBNZSBndXN0YSB2ZXIgbG9zIHJlc3VsdGFkb3MgdmlzdWFsZXMgaW5tZWRpYXRvcy5cIlxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgXG4gICAgICBjb25zb2xlLmxvZyhcIuKchSBSZXBvcnRlcyBkZSBtdWVzdHJhIGNyZWFkb3MgZXhpdG9zYW1lbnRlXCIpXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCLinYwgRXJyb3IgY3JlYW5kbyByZXBvcnRlcyBkZSBtdWVzdHJhOlwiLCBlcnJvcilcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY29uc29sZS5sb2coXCLinIUgUmVwb3J0ZXMgZGUgbXVlc3RyYSB5YSBleGlzdGVuLCBubyBzZSByZWluaWNpYWxpemFuXCIpXG4gIH1cbn1cblxuLy8gSW5pdGlhbGl6ZSBvbiBtb2R1bGUgbG9hZFxuaW5pdERlZmF1bHRVc2VycygpXG5cbi8vIFN0YXJ0IGNvbnZlcnNhdGlvbiBjbGVhbnVwIGludGVydmFsXG5zZXRJbnRlcnZhbChjbGVhbnVwT2xkQ29udmVyc2F0aW9ucywgMzAgKiA2MCAqIDEwMDApIC8vIEV2ZXJ5IDMwIG1pbnV0ZXMiXSwibmFtZXMiOlsiZ2xvYmFsRm9yU3RvcmFnZSIsImdsb2JhbFRoaXMiLCJ0ZW1wVXNlcnMiLCJ0ZW1wV2Vla2x5UmVwb3J0cyIsImFkZFVzZXIiLCJ1c2VyIiwicHVzaCIsImZpbmRVc2VyQnlFbWFpbCIsImVtYWlsIiwiZmluZCIsImZpbmRVc2VyQnlTdHVkZW50SWQiLCJzdHVkZW50SWQiLCJmaW5kVXNlckJ5SWQiLCJpZCIsImdldEFsbFVzZXJzIiwiZmluZFVzZXJzQnlSb2xlIiwicm9sZSIsImZpbHRlciIsImZpbmRVc2Vyc0J5UHJvZ3JhbSIsInByb2dyYW0iLCJmaW5kVXNlcnNCeVN0YXR1cyIsInN0YXR1cyIsInVwZGF0ZVVzZXIiLCJ1cGRhdGVzIiwidXNlckluZGV4IiwiZmluZEluZGV4IiwidXBkYXRlZEF0IiwiRGF0ZSIsImRlbGV0ZVVzZXIiLCJzcGxpY2UiLCJ2YWxpZGF0ZVN0dWRlbnRJZCIsInN0dWRlbnRJZFJlZ2V4IiwidGVzdCIsImdlbmVyYXRlU3R1ZGVudElkIiwiY3VycmVudFllYXIiLCJnZXRGdWxsWWVhciIsImV4aXN0aW5nSWRzIiwic3RhcnRzV2l0aCIsIm1hcCIsInNvcnQiLCJuZXh0TnVtYmVyIiwibGVuZ3RoIiwibGFzdElkIiwibGFzdE51bWJlciIsInBhcnNlSW50Iiwic3BsaXQiLCJ0b1N0cmluZyIsInBhZFN0YXJ0IiwiYWRkV2Vla2x5UmVwb3J0IiwicmVwb3J0IiwiZmluZFdlZWtseVJlcG9ydHNCeVVzZXIiLCJ1c2VySWQiLCJmaW5kV2Vla2x5UmVwb3J0QnlVc2VyQW5kV2VlayIsIndlZWtTdGFydCIsImdldFRpbWUiLCJnZXRBbGxXZWVrbHlSZXBvcnRzIiwiZ2V0V2Vla2x5UmVwb3J0c0J5RGF0ZVJhbmdlIiwic3RhcnREYXRlIiwiZW5kRGF0ZSIsIndlZWtFbmQiLCJnZXRDdXJyZW50V2Vla1N0YXJ0Iiwibm93IiwibW9uZGF5IiwiZGF5IiwiZ2V0RGF5IiwiZGlmZiIsImdldERhdGUiLCJzZXREYXRlIiwic2V0SG91cnMiLCJnZXRDdXJyZW50V2Vla0VuZCIsImNhblN1Ym1pdFRoaXNXZWVrIiwiY3VycmVudERhdGUiLCJleGlzdGluZ1JlcG9ydCIsImlzQ3VycmVudFdlZWsiLCJjb25zb2xlIiwibG9nIiwidG9JU09TdHJpbmciLCJnZXRXZWVrRGF0ZXMiLCJkYXRlIiwic3RhcnQiLCJlbmQiLCJnZXRNb250aFdlZWtzIiwieWVhciIsIm1vbnRoIiwid2Vla3MiLCJmaXJzdERheSIsImxhc3REYXkiLCJjdXJyZW50IiwiZGF5T2ZXZWVrIiwiZGF5c1RvU3VidHJhY3QiLCJnZXRFdmVudHMiLCJnZXRVc2VyQ2FsZW5kYXJEYXRhIiwicmVxdWlyZSIsInVzZXJEYXRhIiwiZXZlbnRzIiwiZXJyb3IiLCJnZXRBbGxDYWxlbmRhckV2ZW50cyIsImdldFVwY29taW5nRXZlbnRzIiwiZGF5cyIsImFsbEV2ZW50cyIsImZ1dHVyZURhdGUiLCJldmVudCIsImV2ZW50RGF0ZSIsImEiLCJiIiwiZ2V0RXZlbnRzRm9yRGF0ZVJhbmdlIiwiZmluZEV2ZW50QnlJZCIsImV2ZW50SWQiLCJnbG9iYWxGb3JDb252ZXJzYXRpb25zIiwidGVtcENvbnZlcnNhdGlvbnMiLCJnZXRDb252ZXJzYXRpb25TZXNzaW9uIiwic2Vzc2lvbklkIiwic2Vzc2lvbiIsImNyZWF0ZUNvbnZlcnNhdGlvblNlc3Npb24iLCJleGlzdGluZ0luZGV4IiwibmV3U2Vzc2lvbiIsInR1cm5zIiwiY3VycmVudFRvcGljIiwidW5kZWZpbmVkIiwiY3VycmVudFN1YmplY3QiLCJwZW5kaW5nVGFza3MiLCJsYXN0VXBkYXRlIiwidXBkYXRlQ29udmVyc2F0aW9uU2Vzc2lvbiIsImluZGV4IiwicyIsImFkZENvbnZlcnNhdGlvblR1cm4iLCJjb250ZW50IiwibWV0YWRhdGEiLCJ0dXJuIiwiTWF0aCIsInJhbmRvbSIsInN1YnN0ciIsInRpbWVzdGFtcCIsInNsaWNlIiwiYWRkUGVuZGluZ1Rhc2siLCJ0eXBlIiwiZGVzY3JpcHRpb24iLCJkYXRhIiwidGFzayIsImNvbXBsZXRlZCIsImNyZWF0ZWRBdCIsIm1hcmtUYXNrQ29tcGxldGVkIiwidGFza0lkIiwicmVzdWx0IiwidCIsImdldFBlbmRpbmdUYXNrcyIsImdldENvbnZlcnNhdGlvbkhpc3RvcnkiLCJsaW1pdCIsImdldFVzZXJBY3RpdmVTZXNzaW9ucyIsIm9uZUhvdXJBZ28iLCJjbGVhbnVwT2xkQ29udmVyc2F0aW9ucyIsInNpeEhvdXJzQWdvIiwiYmVmb3JlIiwiaSIsImFmdGVyIiwiYmNyeXB0IiwiaW5pdERlZmF1bHRVc2VycyIsInN0dWRlbnRFeGlzdHMiLCJpbnN0cnVjdG9yRXhpc3RzIiwiaGFzaGVkUGFzc3dvcmQiLCJoYXNoU3luYyIsIm5hbWUiLCJwYXNzd29yZCIsImVucm9sbG1lbnRZZWFyIiwiYWNhZGVtaWNZZWFyIiwicGhvbmVOdW1iZXIiLCJkYXRlT2ZCaXJ0aCIsImFkZHJlc3MiLCJlbWVyZ2VuY3lDb250YWN0IiwicGhvbmUiLCJyZWxhdGlvbnNoaXAiLCJpbml0U2FtcGxlUmVwb3J0cyIsImV4aXN0aW5nU2FtcGxlUmVwb3J0cyIsImN1cnJlbnRXZWVrIiwiY3VycmVudFdlZWtFbmQiLCJwcmV2V2VlayIsInByZXZXZWVrRW5kIiwic3VibWl0dGVkQXQiLCJyZXNwb25zZXMiLCJ0ZW1hc1lEb21pbmlvIiwiZXZpZGVuY2lhQXByZW5kaXphamUiLCJkaWZpY3VsdGFkZXNFc3RyYXRlZ2lhcyIsImNvbmV4aW9uZXNBcGxpY2FjaW9uIiwiY29tZW50YXJpb3NBZGljaW9uYWxlcyIsInR3b1dlZWtzQWdvIiwidHdvV2Vla3NBZ29FbmQiLCJzZXRJbnRlcnZhbCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/temp-storage.ts\n"));

/***/ })

});